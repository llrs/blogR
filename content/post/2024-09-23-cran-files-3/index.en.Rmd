---
title: "Exploring CRAN's files: part 3"
subtitle: 'References: links between pages, packages and base R'
author: Lluís Revilla Sancho
date: '2024-09-23'
slug: cran-files-3
categories:
  - CRAN
  - r
tags:
  - r
  - packages
  - cran-files
authors:
  - admin
description: ''
draft: no
editor_options:
  chunk_output_type: console
featured: yes
image:
  caption: ''
  focal_point: ''
summary: 'Exploring references'
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, fig.retina = 2, cache = TRUE, include = TRUE, echo = FALSE, warning = FALSE, error = FALSE, message = FALSE, eval = TRUE)
Sys.setlocale("LC_ALL", "C")
Sys.setenv(R_CRAN_WEB = "https://cloud.r-project.org")
```


In the blog post of CRAN files, I [initially explored the database](https://llrs.dev/post/2022/07/23/cran-files-1/) (mostly around `CRAN_package_db()`). On the [second post](https://llrs.dev/post/2022/07/28/cran-files-2/) I moved to analyze the archive around `CRAN_archive_db()`.

Recently at useR!2024, Kurt Hornik offered to export data from CRAN, after an email [several new functions were exported](https://developer.r-project.org/blosxom.cgi/R-devel/NEWS/2024/08/22#n2024-08-22) and introduced to base R.

In that presentation and in a previous exchange with Kurt, he explained his project about providing the HTML manual pages of all CRAN packages.
One of the problems with this projects is providing links to the right pages of the packages (others are making it accessible for all users).

In R-devel now there are test that ensure links to other pages are in the right format [^1].
In this post we we'll explore links between documentation pages, what do manuals write about it and what is the state of base R and the packages.

[^1]: By setting `_R_CHECK_XREFS_NOTE_MISSING_PACKAGE_ANCHORS_=true` as environmental variable.

# Introduction

Help pages are defined in R documentation files, commonly with the `.Rd` extension.
Each documentation file can have multiple topics.
A topic is defined in R documentation format with `\alias{topic}`, so I might use interchangeably alias and topics.
Links, or cross-references (xref for short) [should be to an alias](https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Cross_002dreferences), not to files (allowing to move topics between help pages). 

One can define links with `\link{alias}` or `\link[=alias]{name}` if the link is to a different place than the name [^2]. 
In the second form the content within the square bracket is known as anchor.

There are two other forms accepted: `\link[pkg]{alias}` and `\link[pkg:alias]{name}` which do not use the = inside the square brackets [^3]. 
These are only used in the HTML format. 
Packages referred to on these square brackets should be declared in the DESCRIPTION file, in the ‘Depends’, ‘Imports’, ‘Suggests’ or ‘Enhances’ fields.

One important thing is that links are case sensitive: see `?Complex` than `?complex`. 

[^2]: There is also the `\linkS4class{abc}` that expands to `\link[=abc-class]{abc}` for S4 classes.

[^3]: So there are three names for (almost) the same thing: topic, alias and anchor. Anchors do not need to be = but should be resolvable.

With this in mind we can check to which packages have more manual pages, have more cross-references, or have an overview help page (those with *pkgname*-package.Rd).
We will also check which documentation pages have more links, are more linked to, or needs its links fixed.

# Base R

Previously there wasn't a way to know the links and aliases in base R since recently (~2024/08/20) there are a new way to get that. 

```{r base}
aliases_base <- tools::base_aliases_db()
xrefs_base <- tools:::base_rdxrefs_db()
```


## Aliases

```{r}
alias2df <- function(x){
  todf <- function(x) {
    data.frame(Source = rep(names(x), lengths(x)),
               Target = unlist(x, FALSE, FALSE))
  }
  l <- lapply(x, todf)
  aliasesDF <- do.call(rbind, l)
  aliasesDF$Package <- rep(names(l), vapply(l, NROW, numeric(1L)))
  rownames(aliasesDF) <- NULL
  aliasesDF[, c("Source", "Target", "Package"), drop = FALSE]
}

aliasesBase <- alias2df(aliases_base)
library("dplyr")
```

There are `r n_distinct(aliasesBase$Source)` help pages with `r n_distinct(aliasesBase$Target)` topics/aliases.

```{r}
dup_files <- aliasesBase |> 
  select(-Target) |> 
  distinct() |> 
  summarise(.by = Source, 
            dup_pages = n(),
            packages = paste(Package, collapse = ", ")) |> 
  arrange(-dup_pages) |> 
  filter(dup_pages > 1L) |> 
  head()

dup_files
```

So there are some help files with the same name in base R that can be accessed via their Targets (via `?Target`):

To distinguish between those files one need to check the title(s) and content of the pages.

Similarly there are multiple help pages of different packages with the same topics:

```{r}
dup_targets <- aliasesBase |> 
  summarise(.by = Target, n = n(), Package = paste0(Package, collapse = ", ")) |> 
  filter(n > 1) |> 
  arrange(Target, Package) |> 
  select(Alias = Target, Package)
dup_targets
```

Most of them are in the base and other packages, from the methods package to tools, grDevices, graphics, and utils.


```{r}
dup_pages <- aliasesBase |> 
  filter(.by = Source, Target %in% dup_targets$Alias) |> 
  filter(.by = c(Source, Package), n() == 1) |> 
  select(Package, Target, Source) |> 
  arrange(Target, Package, Source)
```

From these there are `r nrow(dup_pages)` help pages that do not have any other alias.
To access them directly one needs to use `help()`: `help("clipboard", package = "utils")` otherwise one will need to choose them from the menu it will pop up from using `?clipboard`.
This works to access any other help page too.

Last, we can check the topics for a the packages help page.
While usually packages have two alias `pkg` and one `pkgname-package` there are two packages that do not have this: the grid package and the methods package:


```{r}
aliasesBase |> 
  filter(grepl("-package.Rd", Source)) |> 
  filter(.by = Package, sum(Target == Package, 
                            grepl(unique(paste0(Package, "-package")), Target)) != 2) |> 
  select(Package, Source, Alias = Target)
```

These packages lack the form of `pkgname` to find the package help file.

## Cross references

We check the cross references in base R.

```{r}
xrefs2df <- function(x) {
  rdxrefsDF <- do.call(rbind, x)
  rdxrefsDF <- as.data.frame(rdxrefsDF)
  rdxrefsDF$Package <- rep(names(x), vapply(x, NROW, numeric(1L)))  
  rownames(rdxrefsDF) <- NULL
  rdxrefsDF[, c("Source", "Target", "Anchor", "Package"), drop = FALSE]
  rdxrefsDF
}
xrefBase <- xrefs2df(xrefs_base)
```

We can check links and anchors in base packages:
```{r}
library("ggplot2")
xrefBase |> 
  group_by(Package, Source) |> 
  count(Change_name = nzchar(Anchor)) |> 
  ungroup() |> 
  arrange(Package, Source, Change_name) |> 
  mutate(.by = c(Package), help_pages = n_distinct(Source)) |> 
  summarise(.by = c(Package, Change_name, n, help_pages), size = n()) |> 
  ggplot() +
  geom_point(aes(n, forcats::fct_reorder(Package, help_pages, .fun = min), 
                 shape = Change_name, colour = Change_name, size = size), 
             position = position_jitterdodge(jitter.height =  0.25)) +
  theme_minimal() +
  labs(x = "Links", y = element_blank(),
       title = "Most links in help pages are to what is written",
       subtitle = "Packages sorted by number of help pages with links",
       col = "Changed name", shape = "Changed name") +
  scale_x_continuous(expand = expansion(mult = c(0, NA_real_), add = c(0, 3)),
                     breaks = c(1, 50, 100, 150))
```


Now that it is in a rectangular format we can split the anchor on its elements:

```{r}
xrefBase <- cbind(xrefBase, 
                   strcapture("([[:alnum:].]*{2,})?[:=]?(.*)", 
                              x = xrefBase$Anchor, 
                              proto = data.frame(to_pkg = character(), 
                                                 to_target = character())))
```

We need to fill those that do not have anchors to which targets do they link to.


```{r}
y <- xrefBase[c(1, 3, 17, 366, 529, 537, 5378), ]

fill_xref <- function(z) {
  
  # Anchors with packages
  missing_target <- !startsWith(z$Anchor, "=") & z$to_pkg == z$Anchor & nzchar(z$to_pkg)
  z$to_target[missing_target] <- z$Target[missing_target]
  
  # Anchors with = to base packages with no duplicates
  anchors_nodup <- startsWith(z$Anchor, "=") & !z$Anchor %in% dup_targets$Alias
  match_target <- match(z$to_target[anchors_nodup], aliasesBase$Target)
  z$to_pkg[anchors_nodup] <- aliasesBase$Package[match_target]
  
  # Anchors with = to packages with duplicates
  anchors_dup <- startsWith(z$Anchor, "=") & z$Anchor %in% dup_targets$Alias
  z$to_pkg[anchors_dup] <- z$Package[anchors_dup]
  
  # No anchors
  no_anchor <- !nzchar(z$Anchor)
  match_target <- match(z$Target[no_anchor], aliasesBase$Target)
  z$to_pkg[no_anchor] <- aliasesBase$Package[match_target]
  z$to_target[no_anchor] <- aliasesBase$Target[match_target]
  z
}

xrefBase2 <- fill_xref(xrefBase)
# We can then add the aliases to know to which help page do they link.
xrefBase3 <- merge(xrefBase2, aliasesBase,
            by.x = c("to_pkg", "to_target"), 
            by.y = c("Package", "Target"), 
            all.x = TRUE, sort = FALSE) |> 
  select(Rd_origin = Source.x, Anchor, Target, Package, to_pkg, to_target, Rd_destiny = Source.y)
# As expected, xref to other packages not in base R are not included. 
```

As way to validate we can check that base R packages do not have missing links:

```{r}
missing_links_base <- xrefBase3 |> 
  filter(is.na(Rd_destiny), to_pkg %in% names(aliases_base)) |> 
  select(Rd_origin, Package, Anchor)
missing_links_base
```

Surprisingly there are `r nrow(missing_links_base)` links that do not exists: `help(package = "tools", topic = "print.via.format")` and `help(package = "methods", topic = "RMethodUtils")`.
The first one seems a typo as topic `.print.via.format` does resolve while the second one it seems like a file name was used instead of a topic from the RMethodUtils.Rd file (or simply using `isRematched` as topic). 

Looking for other weird links we can check for pages that link to themselves.
The crossreference system doesn't provide a way to link to a specific section  (yet?). 
This means these links are not helpful as users might expect to get redirected to another help page and instead they end up at the top page of the page they were.

```{r}
self_xref <- xrefBase3 |> 
  filter(Rd_origin == Rd_destiny, Package == to_pkg) |> 
  select(Rd_origin, Target, Package)
```


There are currently `r nrow(self_xref)` help files that link to themselves!
As the links are not to specific sections I think they could be deleted. 

There are the help files with more references to other documentation. 

```{r}
# Explore the information
xrefBase3 |> 
  filter(!is.na(Rd_destiny)) |> 
  filter(to_pkg == "graphics", Rd_destiny == "par.Rd") |> 
  summarise(.by = Package, 
            help_pages = n_distinct(Rd_origin)) |> 
  arrange(-help_pages)
  # summarise(.by = c(to_pkg, Rd_destiny), nrefs = n(),
            # )
  # count(to_pkg, Rd_destiny, sort = TRUE)
summarise(xrefBase3, 
          .by = c(Package, to_pkg), 
          n = n(), 
          ndocs = n_distinct(Rd_origin), 
          nlinks = n_distinct(to_pkg, to_target), 
          ndocs_d = n_distinct(to_target)) |> 
  View("a")
```


### To CRAN

We can also ask which packages are linked from R that are not part of R?

```{r}
db <- tools::CRAN_package_db()
xrefBase3 |> 
  filter(nzchar(to_pkg),
         !to_pkg %in% names(aliases_base)) |> 
  count(to_pkg, sort = TRUE, name = "xrefs") |> 
  left_join(db[, c("Package", "Priority", "Maintainer")],
            by = join_by(to_pkg == Package),
            multiple = "first") |> 
  mutate(Maintainer = gsub(" <.+", "", Maintainer),
         `Core member` = Maintainer %in% c("Brian Ripley", "Martin Maechler", "Deepayan Sarkar", "R Core Team", "Kurt Hornik")) |> 
  arrange(-xrefs, Priority, -`Core member`, to_pkg) |> 
  rename(Package = to_pkg)
```

We can see that some packages linked from base R are from the recommended packages and many from the R core members.
Some other links include popular packages. 

# CRAN packages

Now that we have the tools ready we can explore all the CRAN packages.

## Aliases

As before we start exploring CRAN aliases:

```{r}
aliases_CRAN <- tools:::CRAN_aliases_db()
aliasesCRAN <- alias2df(aliases_CRAN)

aliasesCRAN |> 
  summarise(.by = Package, n = n_distinct(Source)) |> 
  arrange(-n) |> 
  head()
```

We can also find those targets that are duplicated on CRAN:

```{r}
dup_cran <- aliasesCRAN |> 
  summarise(.by = Target, n = n_distinct(Package), 
            Package = paste(Package, collapse = ", ")) |> 
  arrange(-n) |> 
  filter(n > 1)

# library("tidygraph")
# library("ggraph")
# ab <- aliasesCRAN |> 
#   filter(.by = Target, n_distinct(Package) > 1) |> 
#   arrange(Target) |> 
#   select(Target, Package) |> 
#   mutate(f = 1) |> 
#   tidyr::pivot_wider(id_cols = Target, names_from = Package, values_from = f, values_fill = 0)
  
  # as_tbl_graph() |> 
  # mutate(Popularity = centrality_degree(mode = 'in')) |> 
  # ggraph(layout = "kk") +
  # geom_edge_fan(aes(alpha = after_stat(index)), show.legend = FALSE) + 
  # geom_node_point(aes(size = Popularity)) + 
  # theme_graph(fg_text_colour = 'white')
```

## Cross references

```{r}
rdxrefs_CRAN <- tools:::CRAN_rdxrefs_db()
rdxrefsCRAN <- xrefs2df(rdxrefs_CRAN)

rdxrefsCRAN <- cbind(rdxrefsCRAN, 
                     strcapture("([[:alnum:].]*{2,})?[:=]?(.*)", 
                                x = rdxrefsCRAN$Anchor, 
                                proto = data.frame(to_pkg = character(), 
                                                   to_target = character())))
rdxrefsCRAN <- fill_xref(rdxrefsCRAN)

# Fill with CRAN targets
fill_xref_cran <- function(z) {
  # No anchors assuming they are from CRAN
  no_anchor <- !nzchar(z$Anchor)
  no_anchor_no_dup <- no_anchor & is.na(z[["to_pkg"]]) & !z[["Target"]] %in% dup_cran[["Target"]]
  match_target <- match(z[["Target"]][no_anchor_no_dup], aliasesCRAN[["Target"]])
  # Adding values
  z[["to_pkg"]][no_anchor_no_dup] <- aliasesCRAN[["Package"]][match_target]
  z[["to_target"]][no_anchor_no_dup] <- aliasesCRAN[["Target"]][match_target]
  
  # Adding duplicated Targets/topics at other packages but present on the package
  blank_target <- is.na(z$to_target)
  for (pkg in unique(z[["Package"]][blank_target])) {
    z_keep <- z[["Package"]] == pkg & blank_target
    alias_keep <- aliasesCRAN[["Package"]] == pkg
    m <- match(z[["Target"]][z_keep], aliasesCRAN[["Target"]][alias_keep])
    z[["to_target"]][z_keep] <- aliasesCRAN[["Target"]][alias_keep][m]
    z[["to_pkg"]][z_keep] <- aliasesCRAN[["Package"]][alias_keep][m]
  }
  z
}
rdxrefsCRAN2 <- fill_xref_cran(rdxrefsCRAN)
rdxrefsCRAN3 <- merge(rdxrefsCRAN2, rbind(aliasesBase, aliasesCRAN), 
            by.x = c("to_pkg", "to_target"), 
            by.y = c("Package", "Target"), 
            all.x = TRUE, sort = FALSE) |> 
  select(Rd_origin = Source.x, Anchor, Target, Package, to_pkg, to_target, Rd_destiny = Source.y)
```

### Continue here


```{r}
missing <- xrefBase3 |> 
  filter(is.na(Rd_destiny)) |> 
  select(-Rd_destiny, Source = Rd_origin)
xrefBase3_m <- merge(missing, aliasesCRAN, 
            by.x = c("to_pkg", "to_target"), 
            by.y = c("Package", "Target"), 
            all.x = TRUE, sort = FALSE) |> 
  select(Rd_origin = Source.x, Anchor, Target, Package, to_pkg, to_target, Rd_destiny = Source.y)

xrefBase4 <- xrefBase3 |> 
  filter(!is.na(Rd_destiny)) |>
  rbind(xrefBase3_m)

```

```{r}
count(xrefBase4, is.na(Rd_destiny))
tpd <- tools::package_dependencies(db$Package, 
                            db = db, 
                            which = c("Depends", "Imports", "Suggests", "Enhances"))
in_tpd <- function(pkg) {
  tpd[[unique(pkg)]]
}
mis <- rdxrefsCRAN3 |> 
  filter() |> 
  summarise(.by = Package, 
            missing_destiny = any(is.na(Rd_destiny)),
            missing_anchors = any(!nzchar(Anchor)),
            not_base = any(missing_anchors & !is.na(to_pkg) & !to_pkg %in% names(aliases_base)), 
            missing_other = any(missing_anchors & !is.na(to_pkg) & to_pkg != Package),
            missing_dependency = any(!is.na(to_pkg) & !to_pkg %in% c(Package, in_tpd(Package))),
            missing_package = !to_pkg %in% c(names(rdxrefs_CRAN), names(xrefs_base)),
            any = any(not_base, missing_other, missing_dependency)
  ) |> 
  filter(missing_destiny | any)
```


```{r}
ccd <- tools::CRAN_check_details()
mis2 <- ccd |> 
  as.data.frame() |> 
  filter(Check == "Rd cross-references") |> 
  distinct(Package)

mis2$type <- "rd_cross_reference"
m <- merge(mis2, mis, all = TRUE)
count(m, type, missing_destiny, missing_anchors)
filter(m, !is.na(type), is.na(missing_destiny), is.na(missing_anchors)) |> 
  pull(Package) |> 
  head()
sdm <- setdiff(mis2$Package, mis$Package[mis$missing_anchors])
sdm2 <- setdiff(mis$Package[mis$missing_anchors], mis2$Package)

  count()
```




```{r}
missing_anchors <- rdxrefsCRAN3 |> 
  summarise(.by = Package, missing = sum(is.na(to_target)), n = n()) |> 
  arrange(-missing)

missing_anchors |> 
  mutate(rate = missing/n) |> 
  left_join(count(aliasesCRAN, Package, name = "Help pages")) |> 
  ggplot() +
  geom_point(aes(`Help pages`, n, size = rate))
```


```{r}
sources_alias <- aliasesCRAN |> 
  summarise(.by = packages, 
            n_sources = n_distinct(Source), 
            n_alias = n_distinct(Target)) |> 
  arrange(-n_sources, -n_alias) 

sources_alias |> 
  count(n_sources, n_alias) |> 
  ggplot() + 
  geom_point(aes(n_sources, n_alias, size = n))
```



```{r}
CRAN <- rbind(aliasesCRAN, rdxrefsDF) |> 
  sort_by(~packages + Source)
CRAN2 <- CRAN |> 
  mutate(needs_fix = !startsWith(Anchor, "=") & 
           !grepl(":", Anchor, fixed = TRUE) & 
           !is.na(Anchor),
         strcapture("([[:alnum:].]*{2,})?[:=]?(.*)", 
                    x = Anchor, 
                    proto = data.frame(to = character(), 
                                       alias = character())))

CRAN3 <- mutate(CRAN2, .by = c(packages), 
                valid = !is.na(Anchor) & alias %in% Source)
```


<details>
<summary>Missing anchors in your package but not a note from CRAN?</summary>

While checking this I realized packages I maintain don't have anchors and I explored why.

The reasons is I use [roxygen2](https://cran.r-project.org/package=roxygen2) for documentation, so for all links and cross-references. 
However, roxygen2 cross-references in `@family tag` do not follow the same pattern as other cross-references. See [the issue](https://github.com/r-lib/roxygen2/issues/1650) for more information.
</details>


```{r}
rdxrefs <- tools:::CRAN_rdxrefs_db()
## Note that as of 2024-06-11, 7139 CRAN packages have no Rd xrefs:
(n1 <- sum(lengths(rdxrefs) == 0L))

xdf <- tools:::.Rd_rdxrefs_db_to_data_frame(c(tools:::base_rdxrefs_db(),
                                              rdxrefs))

## The ones with package anchors:
ind <- with(xdf, nzchar(Anchor) & !startsWith(Anchor, "="))

targets_with_no_package_anchor <- function(x) {
    target <- x$Target
    anchor <- x$Anchor
    source <- x$Source
    names(target) <- source
    names(anchor) <- source
    c(target[!nzchar(anchor)],
      substring(anchor[startsWith(anchor, "=")], 2L))
}

## The ones without package anchors, split according to package:
rdxrefs <- tapply(xdf[!ind, ],
                  sub("::.*", "", xdf$Source[!ind]),
                  targets_with_no_package_anchor,
                  simplify = FALSE)

## As of 2024-06-11, 12304 CRAN packages have Rd xrefs without package
## anchors:
(n2 <- length(rdxrefs))

aliases_in_base <- tools:::base_aliases_db()
aliases_in_CRAN <- tools:::CRAN_aliases_db()

aliases_for_level_0 <-
    lapply(c(aliases_in_base, aliases_in_CRAN),
           unlist, use.names = FALSE)
aliases_for_level_1 <-
    unique(unlist(aliases_in_base, use.names = FALSE))

targets_needing_anchors <-
    Map(function(x, p) {
        x[is.na(match(x,
                      c(aliases_for_level_0[[p]],
                        aliases_for_level_1)))]
    },
    rdxrefs,
    names(rdxrefs))

## As of 2024-06-11, 9860 CRAN packages have Rd xrefs without package
## anchors but do not need any (all non-package-anchored targets are to
## level 0 and new-level-1 base-package only aliases).
(n3 <- sum(lengths(targets_needing_anchors) == 0L))

## This leaves 2444 CRAN packages which need to add package anchors to
## their Rd xrefs:
(n4 <- length(rdxrefs) - sum(lengths(targets_needing_anchors) == 0L))
## Numbers of Rd xrefs needing package anchors:
(tab <- table(lengths(targets_needing_anchors)))
```


# Bioconductor packages

One of the problems of providing HTML manual pages is providing links to the Bioconductor manual pages.
While I have been pressing for having the same file available at the time of writing it is not yet possible to check on them. 

As this is is a recent introduction to R repositories and not compulsory, or mandated by the R-admin section about [setting up repositories](https://cran.r-project.org/doc/manuals/r-release/R-admin.html#Setting-up-a-package-repository) it is not provided by Bioconductor or R-universe or other systems to setup repositories. 

# Conclusions

### Reproducibility

<details>
```{r reproducibility, echo = FALSE}
## Reproducibility info
options(width = 120)
sessioninfo::session_info()
```
</details>
