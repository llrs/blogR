---
title: CRAN updates
author: Llu√≠s Revilla Sancho
date: '`r Sys.Date()`'
slug: cran-updates
categories:
  - CRAN
  - r
tags:
  - R
  - packages
authors: []
description: 'Exploration of the meta archives of CRAN'
draft: no
editor_options:
  chunk_output_type: console
featured: no
image:
  caption: ''
  focal_point: ''
subtitle: "CRAN's package history"
summary: 'Exploration of the CRAN archive: First package on CRAN, dependencies with time, releases sizes and frequency...'
---

## Introduction

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, cache = TRUE, fig.retina = 2)
Sys.setlocale("LC_ALL", "C")
```

There are many great things in base R, one of them is the [tools package](https://search.r-project.org/R/refmans/tools/html/00Index.html).
This package has the functions that are used to build, check and create packages, documentation, manuals. 

Looking into the source code and exploring how it is used by CRAN I found some internal functions that access freely available files with information about CRAN packages.
These private functions are at the [CRANtools.R file](https://svn.r-project.org/R/trunk/src/library/tools/R/CRANtools.R).

```{r internal-functions}
packages <- tools:::CRAN_package_db()
current <- tools:::CRAN_current_db()
archive <- tools:::CRAN_archive_db()
# issues <- tools::CRAN_check_issues()
# alias <- tools:::CRAN_aliases_db()
# rdxrefs <- tools:::CRAN_rdxrefs_db()
```

As I was not sure of the information on these files I asked on [R-devel](https://stat.ethz.ch/pipermail/r-devel/2022-May/081770.html) but id not receive an answer. 
They seem to be quite obscure and as private functions might be removed without notice and shouldn't be used in any dependency.
However, as the files contain information about CRAN they might provide interesting clues about the history of CRAN packages I will explore them.

I will focus on the first three functions as their name is easier to understand what do they access (and I don't want to analyze all the check issues on CRAN now).

### packages file

First of all a very brief exploration of what is in each file:

```{r package-head}
packages[1, 1:10]
```

Packages has similar information as `available.packages()` but with many more columns with published date, reverse dependencies, X-CRAN-Comment, who packaged...
Also note that all this packages are not filtered to match R version, OS_type, subarch and duplicates (I learned about this filtering while reading the great documentation of available.packages and also finding some mentions online). 

### current file

The current database has different data, it has the package size, dates of modification, which I assume is date added to CRAN and user name of who last modified it.
This is the same information returned by [`file.info`](https://search.r-project.org/R/refmans/base/html/file.info.html)

```{r current-head}
current[1, 1:10]
```

### archive file

The archive database returns the same information, but as you might guess by the name it doesn't provide information about current packages but for packages not longer available by default.

```{r archive-head}
archive[[1]]
```

The date matches that available on the [Old sources](https://cran.r-project.org/src/contrib/Archive/A3/).

Now that we know what is in there let's explore the data. 
Some ideas, and questions to explore:

- When were the current [packages accepted on CRAN?](#accepted)
- There is the dates of all packages accepted on CRAN (except those removed): [Are more packages accepted now than in previous years?](#releases)
- There is the date when a package is build and when it is published: How long does it take between a [developer builds the package till it is published on CRAN?](#delays)
- Using the user information; who is [accepting packages on CRAN?](#admins)
- Given the dates, is there some [seasonal patterns in CRAN acceptance?](#season)
- What are the [**oldest** packages on CRAN?](#oldest) 
- What are the [**biggest** packages on CRAN?](#biggest) 
- Are there difference in [size between old and new packages?](#size) 
- Given the dates and versions of packages, [are dependencies related with newer packages or updates?](#dependencies)


First of all some preparation (Note: I'll show all or most of the code used for this analysis); I'll load some libraries used in the post.

```{r libraries, message=FALSE}
library("dplyr")
library("ggplot2")
library("tidyr")
library("ggrepel")
library("lubridate")
library("tools")
library("forcats")
library("flextable")
library("rversions")
library("geomtextpath")
```

As we have data from several years I'll sometimes show the release dates of different R versions to provide some context.

```{r releases-r}
df <- data.frame(major = integer(), minor = integer(), patch = integer())
r_versions <- r_versions() |> 
  mutate(date = as.Date(date),
         strcapture("([0-9])\\.([0-9]*)\\.?([0-9]*)", 
                    version, proto = df),
         equal = major == lag(major, default = TRUE) & minor == lag(minor, default = TRUE))
minor_changes0 <- filter(r_versions, !equal)
minor_changes0[, c("version", "date")] |> 
  flextable() |> 
  autofit()
```

With everything ready let's explore the data:

## Accepted packages {#accepted}

[CRAN was set up in 1997](https://stat.ethz.ch/pipermail/r-announce/1997/000001.html) (Right after the r-testers mailing list was split in [three mailing list](https://stat.ethz.ch/pipermail/r-announce/1997/000000.html)), since then there have been many additions of packages but how fast have been packages accepted? We will use the packages database to answer this. 

First of all some clean up to have all the dates in UTC (not that it will affect much but better to have uniform data), store all the version of packages and add some columns to make it easy relate it with the other files.


```{r packages-setup}
packages$Published <- as.Date(packages$Published, format = "%Y-%m-%d",
                              tz = "UTC")
packages$Packaged_by <- gsub(".*; (.*)", "\\1", packages$Packaged)
packages$Packaged <- as.POSIXct(packages$Packaged, 
                                format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
packages2 <- packages |> 
  mutate(date =  as.Date(Packaged),
         diff = round(difftime(Published, date, units = "days"), 0)) |> 
  mutate(with_archives = Package %in% names(archive)) |> 
  distinct(Package, .keep_all = TRUE)
```

According to this file the oldest current package added was in 2010:

```{r daily-cran}
minor_changes <- filter(minor_changes0, date >= min(packages2$date, 
                                                    na.rm = TRUE))

packages2 |> 
  count(date) |> 
  ggplot() +
  # geom_point(aes(size = n)) +
  geom_text_repel(aes(x = date, y = 25, label = version),
                  data = minor_changes, nudge_x = 0, angle = 90) +
  geom_smooth(aes(date, n), span = "1 month") +
  scale_y_continuous(expand = expansion(0, add = 0.5)) +
  coord_cartesian(ylim = c(0, NA)) +
  scale_x_date(date_breaks = "years", date_labels = "%Y") +
  labs(y = "Packages ", 
       x = element_blank(),
       title = "Daily packages accepted on CRAN") +
  theme_minimal()
```

The daily rate of acceptance has increased from less than 10 a day till 2020 to more than 30 this year 2022.
If we summarize that information for month we see the same, but the little bump in 2020 disappears but we see other patterns:

```{r monthly-cran}
packages2 |> 
  count(month = floor_date(date, "month")) |> 
  ggplot(aes(month, n)) +
  # geom_point(aes(size = n)) +
  geom_smooth(span = 1/12) +
  geom_text_repel(aes(x = date, y = 600, label = version), 
                  data = minor_changes, nudge_x = 0, angle = 90) +
  scale_y_continuous(expand = expansion(0, add = 0.5), position = "right") +
  coord_cartesian(ylim = c(0, NA),
                  xlim = c(as.Date("2010-01-01"), NA)) +
  scale_x_date(date_breaks = "years", date_labels = "%Y") +
  labs(y = "Packages ", 
       x = element_blank(),
       title = "Monthly packages accepted on CRAN") +
  theme_minimal()
```

Instead of just one bump we see some waves with less packages on CRAN accepted late in the year and an increase of packages the first months of the year.
We'll explore this [temporal patterns later](#seasonal).

If we look at the accumulated packages on CRAN we see an exponential growth:

```{r cran-cumsum}
packages2 |> 
  group_by(date) |> 
  count() |> 
  ungroup() |> 
  mutate(nt = cumsum(n)) |> 
  ggplot(aes(date, nt)) +
  # geom_point(aes(size = n)) +
  geom_text_repel(aes(x = date, y = 10000, label = version),
                  data = minor_changes, nudge_x = 0, angle = 90) +
  geom_smooth(span = "1 week") +
  # geom_hline(yintercept = nrow(packages), col = "black") +
  scale_y_continuous(expand = expansion(0, add = 0.5)) +
  coord_cartesian(ylim = c(0, NA)) +
  scale_x_date(date_breaks = "years", date_labels = "%Y") +
  labs(y = "Packages ", 
       x = element_blank(),
       title = "Cumulative sum of packages accepted on CRAN") +
  theme_minimal()
```

In conclusions, more packages are being accepted now than ever in the past.
Are these new packages? As we'll see they are mostly [updates to existing packages](#releases). 

Be it updates or new packages is there some differences between them?

## Developer delays {#delays}

By how [CRAN submission works](https://llrs.dev/post/2021/01/31/cran-review/) it is expected some differences between new packages and already accepted packages. With the existing data we can compare how fast is the process for developers of packages. We can use the published date and compare it with the build date to answer this.

The build date is added to the tar.gz file automatically when the developer builds the package. However, the published date is set by CRAN once the packages are accepted on CRAN.

A first bad exploration of this dates:

```{r cran-built}
#' Convert TRUE, FALSE to Yes, No for easier reading
#' @param x Logical vector
yesno <- function(x) {
  k <- x
  k[x] <- "Yes"
  k[!x] <- "No"
  k
}

ggplot(packages2) +
  geom_point(aes(date, Published, col = as.numeric(diff))) +
  scale_color_viridis_c(trans = "log10") +
  # coord_cartesian(ylim = c(as.Date(min(packages2$Published)), NA),
                  # xlim = c(as.Date(min(packages2$Date)), NA)) +
  scale_x_date(expand = expansion(), date_breaks = "2 year", date_labels = "%Y") +
  scale_y_date(expand = expansion(), date_breaks = "2 year", date_labels = "%Y") +
  theme_minimal() +
  labs(x = "Built",
       y = "Published",
       col = "Difference (days)",
       title = "Time between building a package and being published")
```

We can see some release with a published date early than the packaged day, this might indicate that the CRAN team had to rebuilt the package, a problem with the date settings of my computer or other causes.

To better visualize the differences we can focus on only those with some positive difference between publish date and build.
I will also compare if there is some difference with new packages and packages that were already on CRAN:

```{r cran-delays}
packages2 |> 
  filter(as.numeric(diff) >= 0) |> 
  ggplot() +
  geom_histogram(aes(as.numeric(diff), 
                     fill = fct_relevel(yesno(with_archives), c("Yes", "No"))),
                 position = "identity", alpha = 0.5, binwidth = 7) +
  # facet_wrap(~yesno(with_archives), scales = "free_x") +
  scale_y_log10(expand = expansion()) +
  scale_x_continuous(expand = expansion()) +
  coord_cartesian(xlim = c(0, NA), ylim = c(1, NA)) +
  labs(y = "Packages", 
       x = "Time (days)",
       title = "Time from build to publication",
       fill = "First time?") +
  theme_minimal() +
  theme(legend.position = c(0.7, 0.7))
```

There doesn't seem to be much difference between date of building and date of publication according to if it is the first release or not.
The times are short and usually well below 50 days and too short to notice in this scale.
This doesn't mean that the packages first time accepted on CRAN didn't had previous submissions, but when they finally built and pass the checks and manual review they are handled as with the other packages already on CRAN.

However, this might have changed with time:

```{r cran-delays2}
packages2 |> 
  filter(as.numeric(diff) >= 0) |> 
  group_by(date, with_archives) |> 
  summarize(m = median(diff),
            n = n()) |> 
  ungroup() |> 
  ggplot() +
  geom_smooth(aes(date, m, col = yesno(!with_archives), 
             linetype = yesno(!with_archives), weight = n), span = "1 month") +
  geom_text_repel(aes(x = date, y = 10, label = version),
                  data = minor_changes, nudge_x = 0, angle = 90) +
  scale_y_continuous(expand = expansion()) +
  scale_x_date(date_breaks = "2 years", date_labels = "%Y", 
               expand = expansion(add = 0.5)) +
  coord_cartesian(ylim =  c(0, NA)) +
  labs(y = "Time (days)", 
       x = element_blank(),
       col = "New?",
       linetype = "New?",
       title = "Time between building and on CRAN") +
  theme_minimal() +
  theme(legend.position = c(0.7, 0.7))
```

Here we clearly see that those already on CRAN are handled faster than new packages which take longer to be published.
This is consistent with the manual review process (For more information see [this other blog post](https://llrs.dev/post/2021/01/31/cran-review/)).
It also means that there is a huge variation of time about how packages are handled.
However this seems to be reducing: while in 2010 it took around 2 weeks nowadays it takes less than a week and getting closer to a 1 day of median time  between a package being built and appearing on CRAN that takes for existing packages.

In 2020 we see it took longer than in previous years for packages to be added on CRAN.
Maybe the delay in 2020 was due the huge volume of submissions CRAN received.

<details>
<summary>More packages mean further delays? No, but I'm not sure </summary>

```{r cran-reasons}
packages2 |> 
  filter(as.numeric(diff) >= 0) |> 
  group_by(date, with_archives) |> 
  summarize(m = median(diff),
            n = n()) |> 
  ungroup() |> 
  ggplot() +
  # geom_point(aes(size = n)) +
  geom_smooth(aes(n, m, col = yesno(with_archives), 
             linetype = yesno(with_archives), weight = n)) +
  scale_y_continuous(limits = c(0, NA)) +
  labs(y = "Time (days)", 
       x = "Packages accepted the same day",
       col = "New?",
       linetype = "New?",
       title = "Delay relationship with packages accepted the same day") +
  theme_minimal() +
  theme(legend.position = c(0.7, 0.7))
```

As expected we see a lot of variation on the delay of packages going through manual review.
Surprisingly it the more new packages accepted the same day, the less delay there is, although there is more dispersion on old packages. 
I think this just means that when reviewers get to it several packages might be approved. 
This might also mean packages have already been built several times before finally being accepted and now the errors, warnings and notes have been solved.

For packages already accepted comparing days of delay is not informative as they typically take less than a day (and as short as less than 15 minutes).
However, comparing hours of delay would be misleading as it can simply be the developer taking some time to double check before submission or a time zone difference (submitting in the noon of a region but at the reviewers night).

</details>


## CRAN history

As we have seen there are some files about the archives of CRAN.
These include information about date of modification (moving/editing) and user who did it and of course name and sometimes version of the package.
These archives are the great treasure of CRAN even if we don't have the same information about them as current packages on CRAN.

Note that I'm not sure that this archives contains the full record of packages, some initial packages might be missing and I'm aware of some packages removed by CRAN which do not longer appear on this records. 

Nevertheless this should provide an accurate picture of packages available. 
Also as there is no information when a package is archived (here, [there is on PACKAGES.in](https://llrs.dev/post/2021/12/07/reasons-cran-archivals/)), we might slightly overestimate the packages available at a given moment.

```{r archives-setup}
archive_df <- do.call("rbind", archive)
archives <- vapply(archive, nrow, numeric(1))
pkg <- rep(names(archive), times = archives)
archive_df$package <- pkg

version <- gsub(".*_(.*)\\.tar\\.gz$", "\\1", rownames(archive_df))
archive_df$version <- version
archive_df$version[archive_df$version == archive_df$package] <- NA
archive_df$status <- "archived"

# Make sure they match
current$package <- rownames(current)
current$version <- packages$Version[match(current$package, packages$Package)]
current$status <- "available"
all_packages <- rbind(archive_df, current)

# Arrange dates and data
all_packages$mtime <- with_tz(all_packages$mtime, tzone = "UTC")
keep_columns <- c("package", "mtime", "version", "uname", "size", "status")
all_packages2 <- all_packages[, keep_columns] |> 
  mutate(date = as.Date(mtime)) |> 
  select(-mtime) |> 
  arrange(package, date) |> 
  group_by(package) |> 
  mutate(trelative = difftime(date, min(date), units = "weeks"),
         tprevious = trelative - lag(as.numeric(trelative), default = 0),
         n = n(),
         release = 1:n(),
         available = yesno(any(status == "available"))) |> 
  ungroup()
```

Remember the plot about [acceptance of packages on CRAN?](#accepted)
That plot only looked at current packages available, let's check it with all the archive:

```{r accumulative-packages}
all_packages2 |> 
   group_by(date) |> 
  count() |> 
  ungroup() |> 
  mutate(nt = cumsum(n)) |> 
  ggplot() +
  # geom_point(aes(size = n)) +
  geom_smooth(aes(date, nt), span = "1 week") +
  geom_text_repel(aes(x = date, y = 100000, label = version),
                  data = minor_changes0, nudge_x = 0, max.overlaps = 15, angle = 90) +
  # geom_hline(yintercept = nrow(packages), col = "black") +
  scale_y_continuous(expand = expansion(0, add = 0.5)) +
  coord_cartesian(ylim = c(0, NA)) +
  scale_x_date(date_breaks = "2 years", date_labels = "%Y") +
  labs(y = "Packages ", 
       x = element_blank(),
       title = "Accumulative packages on CRAN archive") +
  theme_minimal()
```

To have an overview of the data we can see some output
If we look at some basics tally to find which packages have more releases:

```{r archives-release}
count(all_packages2, package, sort = TRUE, name = "Releases") |> 
  head(20) |> 
  flextable() |> 
  autofit()
```

Surprisingly there are packages with more than 200 versions on CRAN!

And which CRAN amdin has been moving more packages:

```{r archives-managers}
count(all_packages2, uname, sort = TRUE) |> 
  flextable() |> 
  autofit()
```

Not surprisingly the three top users is dominated by known names associated with CRAN, followed by the root user, perhaps there is an automated script run as root. 
What surprised me more are finding some names, that I associate less with CRAN.
Although Zileis also signs the R-journal sections about CRAN, there are other surnames from people that is not on the R Core. 

```{r packages-available}
all_packages2 |> 
  distinct(package, available) |> 
  count(available, name = "packages", sort = TRUE) |> 
  mutate(proportion = scales::percent(packages/max(packages))) |> 
  flextable() |> 
  autofit()
```

The number of packages currently on CRAN `r nrow(current)` and those not on CRAN are around a 15% of that.

Given all this different versions of packages how big are all the packages on CRAN?

### CRAN size


```{r format-size, include=FALSE}
k <- sum(all_packages2$size)
class(all_packages2$size) <- "object_size"
class(k) <- "object_size"
```

Have you ever wondered how big is CRAN? According to the memory size of the source packages all CRAN source packages are approximately `r format(k, units = "auto")`.

This doesn't include binaries for multiple architectures and OS. 
The package size might indicate whether the package has considerable amount of data.

Looking back to the size of the packages along time we can see this pattern:

```{r packages-size}
all_packages2 |> 
  group_by(date, available, status) |> 
  summarise(s = median(size),
            n = n()) |> 
  ungroup() |> 
  ggplot() +
  geom_smooth(aes(date, s, col = available, linetype = status, weight = n),
              method = "gam") +
  geom_text_repel(aes(x = date, y = 500000, label = version),
                  data = minor_changes0, nudge_x = 0, max.overlaps = 15, angle = 90) +
  labs(x = element_blank(),
       y = "Package size (B)",
       col = "Package on CRAN?",
       linetype = "Version available?",
       title = "Median size of packages in CRAN") +
  scale_y_continuous(expand = expansion(), limits = c(0, NA)) +
  scale_x_date(expand = expansion()) +
  theme_minimal() +
  theme(legend.position = c(0.2, 0.8))
```

Packages available on CRAN are smaller than those no longer on CRAN. 
Even versions of packages on CRAN that got archived are usually bigger than current versions. 
Median size of packages is increasing quickly. 

```{r release-size}
all_packages2 |> 
  group_by(release) |> 
  summarise(s = median(size), n = n()) |> 
  ungroup() |> 
  ggplot() +
  geom_smooth(aes(release, s, weight = n, linewidth = n)) +
  scale_y_log10() +
  geom_hline(yintercept = 5*1000^2) +
  labs(x = "Release number",
       y = "Size (B)",
       title = "Package size with release number") +
  theme_minimal()
```

Typically packages increase their size with new releases up to when they reach 50 releases.

```{r release-size-n, eval=FALSE, include=FALSE}
aps <- all_packages2 |> 
  group_by(package) |> 
  summarise(m = median(size),
            n = n()) |> 
  ungroup() |> 
  arrange(-m)
```


## Releases

As CRAN is not static and there are new releases in a continuous way let's explore other releases.

```{r cran-turnover}
type_updates <- all_packages2 |> 
  group_by(year = floor_date(date, "year"), package) |> 
  summarise(type = case_when(any(release == 1) & any(release > 1) ~ "new & update",
                             any(release > 1) ~ "update",
                             release == 1 ~ "new",
                             TRUE ~ "update"),
            n = n()) |> 
  ungroup() |> 
  distinct(.keep_all = TRUE) |> 
  group_by(year) |> 
  count(type, name = "packages") |> 
  mutate(prop = packages/sum(packages)) |> 
  ungroup()

type_updates |> 
  ggplot() +
  geom_col(aes(year, packages, fill = type), position = "stack") +
  scale_x_date(date_breaks = "2 years", date_labels = "%Y", 
               expand = expansion()) +
  scale_y_continuous(expand = expansion()) +
  theme_minimal() +
  labs(title = "Packages news on CRAN",
       x = element_blank(),
       y = element_blank(),
       fill = "Type") +
  theme(legend.position = c(0.2, 0.75), plot.title.position = "plot")
```

There is an increase number of work on CRAN to update and add new packages.
I counted as new & updated those packages that were inlcuded on CRAN and in the same year they were updated.
This is to keep in mind that [CRAN policies](https://cran.r-project.org/web/packages/policies.html#Submission) says: 

> Once a package is established (which may take several rounds), ‚Äúno more than every 1‚Äì2 months‚Äù seems appropriate. 

To it is kind of expected for new packages to take some time to establish themselves. 

Note that this does not include packages removed from CRAN.

Also note that in 2021 there was the first reduction in packages approvals (around 160). 
This was also noted in the [R journal: changes on CRAN](https://journal.r-project.org/archive/2021-2/cran.pdf) mentioning a reduction in submissions.
It is also worth mentioning the big increase in packages approved for inclusion on CRAN in 2020 (effect of the COVID pandemic?).
Perhaps some packages that would be submitted later got sooner to CRAN?

```{r cran-proportion}
ggplot(type_updates) +
  geom_col(aes(year, prop, fill = type)) +
  scale_y_continuous(labels = scales::label_percent(), expand = expansion(), n.breaks = 10, limits = c(0, 1)) +
  scale_x_date(date_breaks = "2 years", date_labels = "%Y",
               expand = expansion()) +
  theme_minimal() +
  labs(title = "Updates of existing packages on CRAN",
       subtitle = "Percentage of packages",
       x = element_blank(),
       y = element_blank(),
       fill = "Type")
```

Very early on, since 2000, the most frequent action on CRAN is updating a package.
This has remained more or less stable with time close to 80% if we take into account also the new packages that are updated the same year. 

This is consistent with language updates and the increasing requirements to keep a package on CRAN.

Given that updates is the most pressing matter to the CRAN team, let's explore them.

Percentage of packages updated on CRAN: 

```{r packages-updated}
CRAN_till_then <- all_packages2 |> 
  arrange(date) |> 
  group_by(date, package) |> 
  mutate(type = case_when(any(release > 1) ~ "update",
                             release == 1 ~ "new",
                             TRUE ~ "update")) |> 
  ungroup() |> 
  arrange(date) |> 
  mutate(CRAN = cumsum(type == "new"),
         actions = 1:n(),
         updates_cum = cumsum(type == "update")/actions,
         new_cum = CRAN/actions,
         )
CRAN_till_then |>
  ggplot() +
  geom_smooth(aes(date, updates_cum), linetype = 2) +
  geom_smooth(aes(date, new_cum), col = "orange")  +
  scale_y_continuous(expand = expansion(), labels = scales::percent_format()) +
  labs(x = element_blank(),
       y = "CRAN updates",
       title = "Acumulative percentage of actions") +
  theme_minimal()
CRAN_till_then |>
  group_by(date) |> 
  summarise(updates_cran = sum(type == "update")/max(CRAN)) |> 
  ggplot() +
  geom_smooth(aes(date, updates_cran), linetype = 2) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(x = element_blank(),
       y = "% of CRAN",
       title = "Percentage of packages on CRAN updated") +
  theme_minimal()
```

It seems that 0.2% of packages of CRAN is updated daily!
There has been a slow down on packages updated on CRAN since the beginning.

## Updates by date

Updates are new releases to CRAN, looking at the second version of the packages:

```{r second-release}
all_packages2 |> 
  filter(release == 2) |> 
  ggplot() +
  # geom_vline(xintercept = 52*c(1:15), linetype = 2) +
  geom_histogram(aes(trelative), binwidth = 26) +
  labs(x = "Time (weeks)",
       y = "Packages",
       title = "Time since first release") +
  scale_x_continuous(expand = expansion(), breaks = 52*c(1:19)) +
  scale_y_log10(expand = expansion()) +
  theme_minimal()
```

There is a wide range of time between the first release and the next one.
Those that are still on CRAN show any difference to those that are not on CRAN?

```{r second-release-status}
all_packages2 |> 
  filter(release == 2) |> 
  ggplot() +
  # geom_vline(xintercept = 52*c(1:15), linetype = 2) +
  geom_histogram(aes(trelative, 
                     fill = fct_relevel(available, "Yes", "No")), 
                 binwidth = 26, position = "identity", alpha = 0.5) +
  labs(x = "Time (weeks)",
       y = "Packages",
       fill = "On CRAN?",
       title = "Time since first release") +
  scale_x_continuous(expand = expansion(), n.breaks = 18) +
  scale_y_log10(expand = expansion()) +
  theme_minimal() +
  theme(legend.position = c(0.7, 0.7))
```

There doesn't seem to be much difference between packages on CRAN and archived.
Perhaps given the low number of packages no longer on CRAN it is surprising that there are so many updates to later being removed.
This indicates a lot of effort from the package developers that is later no longer available to the users.
The causes of this might be multiple, perhaps they do not have enough time to keep up with the "[publication quality](https://cran.r-project.org/web/packages/policies.html)" standard of CRAN, the package is superseeded by other tools, or there aren't good experiences about updating packages.

```{r releases-times}
all_packages2 |> 
  filter(release <= 6 & release != 1) |> 
  ggplot() +
  # geom_vline(xintercept = 52*c(1:15), linetype = 2) +
  geom_histogram(aes(tprevious, 
                     fill = fct_relevel(available, "Yes", "No")), 
                 binwidth = 26, position = "identity", alpha = 0.5) +
  facet_wrap(~release, scales = "free_x") +
  labs(x = "Time (years)",
       y = "Packages",
       fill = "On CRAN?",
       title = "Time since previous release",
       subtitle = "By number of release") +
  scale_x_continuous(expand = expansion()) +
  scale_y_log10(expand = expansion()) +
  theme_minimal() +
  theme(legend.position = c(0.8, 0.3))
```

This might be obvious but packages currently not on CRAN are not updated as much as those that are.
But note that they are only \~20% of the packages on CRAN, so proportionally removed packages updated more.
Wit this data there isn't any explanation we can make about why aren't packages updated more.

```{r last-release}
all_packages2 |> 
  group_by(package) |> 
  filter(release == max(release) & release != 1) |> 
  ggplot() +
  # geom_vline(xintercept = 52*c(1:13), linetype = 2) +
  geom_histogram(aes(tprevious, 
                     fill = fct_relevel(status, c("available", "archived"))), 
                 binwidth = 26, position = "identity") +
  labs(x = "Time (weeks)",
       y = "Packages",
       fill = "Status",
       title = "Time since previous release") +
  scale_x_continuous(expand = expansion()) +
  scale_y_log10(expand = expansion()) +
  theme_minimal()
```

```{r proportion-packages}
prop_packages <- all_packages2 |> 
  count(release, available) |>
  group_by(release) |> 
  mutate(prop_release = n/sum(n)) |> 
  ungroup() |> 
  group_by(available) |> 
  mutate(prop_available = n/max(n)) |> 
  ungroup()
prop_packages |> 
  ggplot() +
  geom_tile(aes(available, release, fill = n)) +
  # facet_wrap(~available, scales = "free_x") +
  scale_fill_viridis_c(trans = "log10") +
  scale_y_continuous(expand = expansion()) +
  theme_minimal() +
  labs(x = "On CRAN?",
       y = "Releases",
       fill = "Packages",
       title = "Package updates") +
  theme(legend.position = c(0.2, 0.8))
```

By the gradation of colors and length there is a clear sense that packages on CRAN are updated much more and have more releases (even if those pacakges with more than 150 releases are very few).

```{r proportion-pacakges-available}
prop_packages |> 
  ggplot() +
  geom_line(aes(release, prop_available, col = available, linetype = available)) +
  scale_x_continuous(expand = expansion()) +
  scale_y_continuous(expand = expansion(), labels = scales::label_percent()) +
  labs(x = "Release",
       y = "Proportion",
       linetype = "On CRAN?",
       col = "On CRAN?",
       title = "Packages on CRAN are updated more."
       ) +
  theme_minimal() +
  coord_cartesian(xlim = c(0, 50)) +
  theme(legend.position = c(0.7, 0.7))
```

From this plot we can see that packages on CRAN make update more than those who are no longer on CRAN. 
Maybe packages removed are only updated on other platforms (Bioconductor, Github, R-forge), or are no longer maintained.

Similarly the speed of release of each version might be important

```{r releases-speed}
all_packages2 |> 
  mutate(versions = as.character(release)) |>
  ggplot() +
  geom_line(aes(x = as.numeric(trelative), y = release, col = package, 
                group = package), show.legend = FALSE) +
  labs(y = "Release", 
       x = "Time since first release (weeks)", 
       title = "Time since the first release") +
  scale_x_continuous(expand = expansion(), limits = c(0, NA)) +
  theme_minimal() 
```

This porcupine plot shows that most packages don't have many releases and if there are releases they usually take some time. 

A different representation taking into account the time with the previous release:

```{r releases-speed2}
all_packages2 |> 
  filter(release >= 2) |> 
  ggplot() +
  geom_count(aes(x = as.numeric(trelative), as.numeric(tprevious), col = release)) +
  labs(y = "Time sine previous release (weeks)", 
       x = "Time since first release (weeks)", 
       col = "Releases",
       size = "Packages",
       title = "Time between releases") +
  scale_x_continuous(expand = expansion(add = 1), limits = c(0, NA)) +
  scale_y_continuous(expand = expansion(add = 1), limits = c(0, NA)) +
  theme_minimal() 
```

Looking at time since first release and time since previous release we don't see any pattern.
Some packages have few updates but distributed in time while some seem to have more constant distributions but there isn't a clear pattern. 
However, the CRAN policies currently recommends between 1 and 2 updates a month at most (except when there are some problems that need to be fixed in less than 2 weeks).
Looking at packages that have updated more might indicate problems with packages or their dependencies. 


To identify those packages we can look at the general frequency they are updated (if they were ever updated) and if there is any release less than two months apart.

```{r setup-updates}
rle_weeks <- function(x, y) {
  # Wait two months (8 weeks) to have established package
  x <- x[y > 8] 
  rle <- rle(x < 4)
  # Count if there are more than two updates in a month.
  rle$lengths[rle$values ] >= 2
}

packages_updates <- all_packages2 |> 
  filter(n > 1,
         available == "Yes") |> 
  group_by(package) |> 
  summarise(d = min(date),
            max = as.numeric(difftime(Sys.Date(), d), units = "weeks"),
            releases = unique(n),
            m = releases/max,
            trouble2 = rle_weeks(tprevious, trelative)) |> 
  ungroup() |> 
  filter(max > 8) |> 
  mutate(frequent_releases = yesno(m >= 1/8),
         quick_releases = yesno(trouble2))
```

Once we have calculated the frequency of their updates we can classify them on which category they might be, but first let's look at the update rate according to the initial package release

```{r update-rate}
ggplot(packages_updates) +
  geom_smooth(aes(d, m)) +
  theme_minimal() +
  scale_y_continuous(
    "Updates per week",
    sec.axis = sec_axis(~ . / 4, name = "Updates per month")
  ) +
  labs(x = "Release date",
       title = "Update frequency")
```

Developers lately seem to have to update packages more frequently. 
This plot is packages 2 months old on CRAN and the number of releases in their lifetime.
Clearly now there are packages that need to update if faster.

If we split between those that have more troubles (more than 1 updates per 8 weeks as in code), we see that this is happening to all packages recently accepted: 

```{r updates-trouble}
ggplot(packages_updates) +
  geom_smooth(aes(d, m, 
                  col = frequent_releases, 
                  linetype = frequent_releases), 
                  show.legend = FALSE) +
  geom_text_repel(aes(x = date, y = 0.3, label = version),
                  data = minor_changes0, nudge_x = 0, angle = 90) +
  geom_texthline(yintercept = 1/8, label = "CRAN threshold") +
  theme_minimal() +
  scale_y_continuous(
    "Updates per week",
    sec.axis = sec_axis(~ . / 4, name = "Updates per month")
  ) +
  labs(x = element_blank(),
       col =  "Frequent releases",
       lintype = "Frequent releases",
       title = "New packages require more updates")
```

The latest packages require more updates, but we see also see an increase in frequency of updates on those that are not close to CRAN policies.
This is partially expected as the newer the packages less time has passed to bring down the rate.

If we look for quick updates that shouldn't be affected by recent released packages because we discarded the first 2 months of updates to ensure a packages is established and discard the initial rounds of updates (As per policy "Once a package is established (which may take several rounds)", ... )


```{r updates-trouble2}
ggplot(packages_updates) +
  geom_smooth(aes(d, m, 
                  col = quick_releases, 
                  linetype = quick_releases)) +
  geom_text_repel(aes(x = date, y = 0.17, label = version),
                  data = minor_changes0, nudge_x = 0, angle = 90) +
  theme_minimal() +
  scale_y_continuous(
    "Updates per week",
    sec.axis = sec_axis(~ . / 4, name = "Updates per month")
  ) +
  labs(x = element_blank(),
       col = "Quick releases",
       linetype = "Quick releases",
       title = "New packages require more updates")
```

Here surprisingly we see the same pattern, initially in 2000 there were more frequent updates, which were reduced around 2010-2015 but later have increased a lot. 

If we combine both releases frequencies we might get a better picture:

```{r updates-troubled}
ggplot(packages_updates) +
  geom_smooth(aes(d, m, col = quick_releases, linetype = frequent_releases)) +
  geom_text_repel(aes(x = date, y = 0.25, label = version),
                  data = minor_changes0, nudge_x = 0, angle = 90) +
  geom_texthline(yintercept = 1/8, label = "CRAN threshold") +
  theme_minimal() +
  scale_x_date(date_breaks = "2 years", date_labels = "%Y") +
  scale_y_continuous(
    "Updates per week",
    sec.axis = sec_axis(~ . / 4, name = "Updates per month")
  ) +
  labs(x = element_blank(),
       col = "Quick releases",
       linetype = "Frequent releases",
       title = "New packages require more updates")
```

We see an increase in updates right before R 4.0.0 was released by packages that are updated frequently and had to update quickly. 

On packages that do not update quick or frequently we still see an increase on update rate more pronounced since 2019.

This could indicate problems following CRAN policies and keeping up to date with changes in R code and checks.
Despite troubles this also shows that many developers keep developing their packages to keep them on CRAN.
Some succeed some don't and do not longer submit new releases.


```{r updates-percentage}
packages_updates |> 
  group_by(d) |> 
  count(quick_releases, frequent_releases) |> 
  mutate(p = n/sum(n)) |> 
  ungroup() |> 
  mutate(type = case_when(
    quick_releases == "Yes" & frequent_releases == "Yes" ~ "Quick & frequent",
    quick_releases == "Yes" & frequent_releases == "No" ~ "Quick",
    quick_releases == "No" & frequent_releases == "Yes" ~ "Frequent",
    quick_releases == "No" & frequent_releases == "No" ~ "Ideal",
    TRUE ~ "weird"))
  ggplot() +
  geom_smooth(aes(d, p, fill = type), span = "1 month") +
  theme_minimal() +
  scale_x_date(date_breaks = "2 years", date_labels = "%Y") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = element_blank(),
       fill = "Type updates",
       title = "Type of packages by their updates",
       subtitle = "By their release date")
```


Here we can see the proportion of packages that end up on each category of updates by their release date.

## Updates by release

If we look at the released versions.

```{r releases-dates}
all_packages2 |> 
  ggplot() +
  geom_line(aes(x = date, y = release, group = package)) +
  guides(col = "none") +
  labs(y = "Releases", 
       x = "Time since first release (weeks)", 
       title = "Time since the first releast to further releases archival") +
  theme_minimal() 
```

If we look at the time since the first release we observe that currently the second release of a package is released later than previously:

```{r release-dates-days}
all_packages2 |> 
  ggplot() +
  # geom_point(aes(date, trelative), alpha = 0.5) +
  geom_smooth(aes(date, trelative), span = "1 month") +
  scale_x_date(date_breaks = "2 years", date_labels = "%Y") +
  scale_y_continuous(limits = c(0, NA)) +
  labs(x = element_blank(), 
       y = "Time since second release (days)",
       title = "Tendency of time to update the package") +
  theme_minimal()
```

We can see the raw numbers of packages updated by month according to their release number:

```{r updates-summaries}
block <- all_packages2 |> 
  filter(release != 1) |> 
  group_by(month = floor_date(date, "halfyear"),
           release) |> 
  summarise(t = median(tprevious),
            n = n()) |> 
  ungroup() 

block |> 
  filter(release <= 6) |> 
  ggplot() +
  geom_smooth(aes(month, n, size = n, col = as.factor(release),
                  linetype = as.factor(release), weight = n), 
              alpha = 0.25)  +
  scale_x_date(expand = expansion(), date_breaks = "2 year", date_labels = "%Y") +
  scale_y_continuous(expand = expansion()) +
  coord_cartesian(ylim = c(0, NA)) +
  labs(x = element_blank(),
       y = "Packages",
       title = "Updates",
       subtitle = "Release <= 6",
       col = "Releases",
       linetype = "Releases") +
  theme_minimal()
```

As expected by the increase in new packages the number of packages updated decrease with the number of releases.

```{r releases-filtered2}
block |> 
  filter(release <= 6) |> 
  ggplot() +
  geom_smooth(aes(month, t, size = n, col = as.factor(release),
                  linetype = as.factor(release), weight = n), 
              alpha = 0.25)  +
  scale_x_date(expand = expansion(), date_breaks = "2 year", date_labels = "%Y") +
  scale_y_continuous(expand = expansion()) +
  coord_cartesian(ylim = c(0, NA)) +
  labs(x = element_blank(),
       y = "Median time since previous release (weeks)",
       title = "Speed of updates",
       subtitle = "Release <= 6",
       col = "Releases",
       linetype = "Releases") +
  theme_minimal()
  
```

The reasons of this longer updates might be multiple, it might be that packages have become better and require less updates to keep up with the more strict CRAN rules.
It could also mean that maintainers are no longer updating packages and abandoning them, as there are some evidence that lately there have been lots of packages removed from CRAN because they were not keeping up with CRAN policies. 

```{r tweet, echo=FALSE}
blogdown::shortcode('tweet', '1536681188789723139')
```

This has been explored in a previous post about [packages archived by CRAN](https://llrs.dev/post/2021/12/07/reasons-cran-archivals/)  using another (hidden) CRAN file.

## Seasonal effects {#season}

Given the release dates of packages, it could be interesting to know if packages are updated more frequently in January than in August.
We have already seen in the firsts plots that there are some patterns on the acceptance of packages. 

First let's prepare the data to explore patterns by day of the week, day of the year and month:

```{r setup-seasonal}
dates_approval <- all_packages2 |> 
  mutate(year = year(date),
         month = month(date),
         week = week(date),
         yday = yday(date),
         mday = mday(date),
         wday = wday(date, week_start = 1, label = FALSE),
         type = ifelse(release == 1, "new", "update"))

d <- c(1:7)
lab_names <- lubridate::wday(d, week_start = 1, label = TRUE)
names(lab_names) <- as.character(d)
dmonth_breaks <- seq(0, 31, by = 7)
dmonth_breaks[1] <- 1
```

By looking at which month has more accepted packages we might get some clues to developers (and CRAN maintainers) activity:

```{r seasonal-month}
dates_approval |> 
  count(type, year, month) |> 
  ggplot() +
  geom_smooth(aes(month, n, col = type, linetype = type)) +
  theme_minimal() +
  scale_x_continuous(breaks = c(1:12)) +
  labs(y = "Packages", 
       x = "Month",
       col  = "Release",
       linetype = "Release",
       title = "Updates on CRAN packages by month") +
  theme(legend.position = c(0.5, 0.3)) +
  facet_wrap(~type, scales = "free_y")
```

The first 6 months of the year have higher activity on packages already on CRAN, while for new packages the activity is more or less constant with a decrease at the end of the year.


```{r seasonal-week}
dates_approval |>  
  count(type, year, week) |> 
  ggplot() +
  geom_smooth(aes(week, n, col = type, linetype = type)) +
  annotate(geom = "text", 
           x = week(as.Date(months_middle)), 
           y = 55, 
           label = c("April", "July", "November")) +
  theme_minimal() +
  labs(x = "Week",
       y = "Releases",
       col = "Release",
       linetype = "Release",
       title = "Weekly releases on CRAN")
```

As seen on the previous plot the first months have higher releases than later in the year and the increase on updates is around October.

```{r seasonal-yday}
dates_approval |> 
  count(type, year, yday) |> 
  ggplot() +
  geom_smooth(aes(yday, n, col = type, linetype = type)) + 
  annotate(geom = "text", 
           x = yday(as.Date(months_middle)), 
           y = 13, 
           label = c("April", "July", "November")) +
  coord_cartesian(ylim = c(0, 21)) +
  labs(x = "Day",
       y = "Releases",
       col = "Releases",
       linetype = "Releases",
       title = "Daily regresssion of releases") +
  theme_minimal() +
  theme(legend.position = c(0.5, 0.4))
```


At the end of the year, beginning of the next there the submission queue is closed, [for example in 2017](https://stat.ethz.ch/pipermail/r-devel/2017-December/075215.html).
I also [collected](https://github.com/llrs/blogR/issues/57) other dates when the submission queue was closed.
There doesn't seem to be a regular site to announce this, sometimes is on the home page of CRAN sometimes is announced on the mailing lists. 

This doesn't include some [unexpected downtime](https://stat.ethz.ch/pipermail/r-devel/2022-May/081751.html), which recently happened for the first time in my short exposure. 


## Admins

CRAN is not run by bots using some automated rules. 
Although there are automatically rules and many automatic decisions made, some volunteers review the packages to keep the publication quality of packages on CRAN. 

*Note*: Maintaining CRAN involves much more than just moving packages around but I don't have more information than this on this file. 
A CRAN volunteer might be very active in other ways not shown here. 
For instance, the recent update on [CRAN task view initiative](https://github.com/cran-task-views/ctv#cran-task-view-editors) leaded by some members that do not appear on the following plots.

Looking at those that have contributed more to move around packages we have the following usernames:

```{r setup-people}
people <- dates_approval |> 
  count(uname) |> 
  filter(n > 1000) |> 
  pull(uname)
dates_approval |> 
  filter(uname %in% people) |>
  group_by(uname) |> 
  summarise(min = min(date),
            max = max(date),
            n = n()) |> 
  arrange(min)
```

We can see that there are three users active for more than 10 years!
Many thanks to them!!

```{r people-active}
dates_approval |> 
  count(year, uname) |> 
  ggplot() +
  geom_textline(aes(year, n, 
                col = fct_other(uname, keep = people, other_level = "other"),
                linetype = fct_other(uname, keep = people, other_level = "other"),
                label = fct_other(uname, keep = people, other_level = "other")), show.legend = FALSE, hjust = 0.55) +
  labs(col = "Users", 
       linetype = "Users",
       y = "Package movements",
       title = "Activity of CRAN managers") +
  theme_minimal()
```

Here we can see the different actions by each one.
To have a better view of the changes on who is moving CRAN packages we can make this other visualization:

```{r people-active}
theme(legend.position = c(0.3, 0.7))
dates_approval |> 
  count(year, uname) |> 
  ggplot() +
  geom_area(aes(year, n, 
                fill = fct_other(uname, keep = people, other_level = "other"),
                linetype = fct_other(uname, keep = people, other_level = "other"))) +
  labs(fill = "Users", 
       linetype = "Users",
       y = "Package movements",
       title = "Activity of CRAN managers") +
  theme_minimal() +
  theme(legend.position = c(0.3, 0.7))
```


There are some patterns here on people volunteering on CRAN.
Initially the root user was used to manage CRAN packages.
Since 2005 Kurt Hornik started moving the packages, I suppose he was behind the root account previously.
Brian Ripley moved most of the packages between 2010 and 2015.
Around that time Uwe Ligges started moving the packages and has been doing the shear work of moving them since 2015 (Although Kurt Hornik participated more in 2015 to 2017 than on the previous years 2010 - 2015).
There is also an account of herbrandt which briefly moved packages around 2017.

Previous Volunteers


```{r user-month}
dates_approval |> 
  count(year, month, uname) |> 
  ggplot() +
  geom_textsmooth(aes(month, n, 
                  col = fct_other(uname, keep = people, other_level = "other"),
              linetype = fct_other(uname, keep = people, other_level = "other"))) +
  labs(col = "Users",
       linetype = "Users",
       y = "Moves",
       title = "Activity of users by month") +
  scale_x_continuous(breaks = 1:12) +
  theme_minimal()
```



```{r user-week}
dates_approval |>  
  count(year, week, uname) |> 
  ggplot() +
  geom_smooth(aes(week, n, 
                  col = fct_other(uname, keep = people, other_level = "other"),
                  linetype = fct_other(uname, keep = people, other_level = "other"))) +
  labs(col = "Users",
       linetype = "Users",
       y = "Moves",
       title = "Activity of users by week") +
  theme_minimal()
```

We can clearly see the same pattern than with packages accepted on CRAN: at the end of the year there is less activity of Uwe Ligges and we see a dip also on Kurt Hornik activity.

```{r user-wday}
dates_approval |>  
  count(year, month, week, wday, uname) |> 
  ggplot() +
  geom_smooth(aes(wday, n,  col = fct_other(uname, keep = people, other_level = "other")), method = "glm") + 
  labs(col = "Users")
```


```{r user-mday}
dates_approval |> 
  count(year, month, mday, uname) |> 
  ggplot() +
  geom_smooth(aes(mday, n, col = fct_other(uname, keep = people, other_level = "other"))) +
  labs(col = "Users") +
  coord_cartesian(ylim = c(0, NA)) +
  scale_x_continuous(expand = expansion(), breaks = dmonth_breaks,
                       position = "top") +
  scale_y_continuous(expand = expansion())
```


```{r user-yday}
months_middle <- c("2022-04-15", "2022-07-15", "2022-11-15")
dates_approval |> 
  count(year, yday, uname) |> 
  mutate(uname_other = fct_other(uname, keep = people, other_level = "other")) +
  ggplot() +
  geom_smooth(aes(yday, n, col = uname_other)) + 
  labs(col = "Users") +
  annotate(geom = "text", 
           x = yday(as.Date(months_middle)), 
           y = 15, 
           label = c("April", "July", "November")) +
  coord_cartesian(ylim = c(0, NA))
```


### Holidays

Given the high rate of package added and updated in CRAN let's see days without acceptance of packages. 
First some transformation:

```{r setup-holidays}
d1 <- min(all_packages2$date)
d2 <- max(all_packages2$date)
s <- seq(from = d1, to = d2, by = 1)
holiday <- s[!s %in% unique(all_packages2$date)]
holiday <- data.frame(holiday = holiday) |> 
  mutate(year = year(holiday),
         month = month(holiday),
         week = week(holiday),
         yday = yday(holiday),
         mday = mday(holiday),
         wday = wday(holiday, week_start = 1, label = FALSE))
```

Then some plots by week:

```{r holidays-week}
holiday |>  
  count(year, week) |> 
  ggplot() +
  geom_smooth(aes(week, n, linewidth = n), span = 1/52) +
  annotate(geom = "text", 
           x = yday(as.Date(months_middle)), 
           y = 2.5, 
           label = c("April", "July", "November")) +
  labs(title = "Weeks without packages updates",
       y = "Years")
```

<!-- Similarly we can see the days of the year without additions: -->

```{r holidays-yday, eval=FALSE, include=FALSE}
holiday |>  
  count(year, yday) |> 
  ggplot() +
  geom_count(aes(yday, n))  +
  labs(title = "Weeks without packages updates",
       y = "Years")
```

Clearly at the end of the year there is a tendency to not accept packages.
Which is usually when the CRAN closes the submission queue for holidays. 
Other maintenance or down time is rare and not on fixed dates.

## Oldest package {#oldest}

Given the archives and the current packages on CRAN.
Which are the oldest packages?
I'm not sure if this date is the archival date or date of the first publication. 
It could be that the release date was earlier and the list might be a bit off. 

```{r cran-oldest}
all_packages2 |> 
  filter(available == "Yes") |> 
  filter(release == 1) |> 
  arrange(date) |> 
  select(package, version, size, date) |> 
  head(10)
```

Which are the oldest packages without any update?

```{r cran-oldest-conserved}
all_packages2 |> 
  filter(available == "Yes") |> 
  group_by(package) |> 
  filter(max(release) == 1) |> 
  ungroup() |> 
  arrange(date) |> 
  select(package, version, size, date) |> 
  head(10)
```

These are the oldest 10 packages released and without any further release on CRAN. 
They are around 10 years old.

But the packages that have been longest on CRAN, be it the first release or not are these:

```{r cran-longest3}
all_packages2 |> 
  filter(available == "Yes" & status == "available") |> 
  arrange(date) |> 
  select(package, version, size, date, release) |> 
  head(10)
```

A couple of the top 10 repeats from those without any update!
They don't fall far from the oldest packages!

Let's show the initial releases of packages:

```{r cran-initial-releases}
never_archived <- all_packages2 |> 
  filter(available == "Yes") |> 
  group_by(package) |> 
  filter(max(release) == 1) |> 
  ungroup() |> 
  pull(package)

all_packages2 |> 
  filter(available == "Yes" & release == 1) |> 
  group_by(month = floor_date(date, "month"),
           same = package %in% never_archived) |> 
  count() |> 
  ungroup() |> 
  ggplot(aes(month, n, fill = yesno(same))) +
  geom_col(position = "identity", alpha = 0.5) +
  scale_x_date(date_breaks = "2 years", date_labels = "%Y") +
  theme_minimal() +
  labs(fill = "Updated?",
       x = element_blank(),
       y = "Packages",
       title = "First archival or release date") +
  theme(legend.position = c(0.3, 0.8))
```


## Dependencies current packages {#dependencies}

Looking at packages with just 1 release but still one package which are those?

This shows the date of the packages in relation to their recursive dependencies.

```{r setup-dependencies}
direct_dep <- tools::package_dependencies(packages2$Package, 
                                          db = packages2)

base_packages <- rownames(installed.packages(priority = "base"))
deps0 <- vapply(direct_dep, function(x){sum(!x %in% base_packages)}, numeric(1L))
deps <- lengths(direct_dep)
recurs_dep <- tools::package_dependencies(packages2$Package, 
                                          db = packages2, recursive = TRUE)
r_deps0 <- vapply(recurs_dep, function(x){sum(!x %in% base_packages)}, numeric(1L))


r_deps <- lengths(recurs_dep)
r_deps <- r_deps0[names(deps0)]
deps_all <- data.frame(direct_deps = deps0,
                       r_deps)
deps_all$Package <- rownames(deps_all)
```


```{r dependencies-current}
deps_all |> 
  ggplot() +
  geom_count(aes(direct_deps, r_deps, col = after_stat(n))) +
  scale_size(trans = "log10") +
  scale_color_viridis_c(trans = "log10", begin = 0, end = 1, direction = -1) +
  scale_y_log10() +
  labs(x = "Direct", y = "Indirect",
       size = "Packages",
       col = "Packages",
       title = "Relationship between direct and indirect dependencies") +
  theme_minimal()
```


```{r dependencies-type}
packages2 |> 
  merge(deps_all, by = "Package", all = TRUE) |> 
  mutate(archived = yesno(Package %in% never_archived)) |> 
  select(date, direct_deps, r_deps, archived) |> 
  pivot_longer(c(direct_deps, r_deps), names_to = "dependency") |> 
  mutate(dependency = ifelse(dependency == "direct_deps", "direct", "recursive")) |> 
  ggplot() +
  geom_smooth(aes(date, value, col = archived, linetype = dependency), span = 1/24) +
  scale_y_log10(limits = c(1, NA), expand = expansion()) +
  scale_x_date(expand = expansion(), date_breaks = "2 years",
               date_labels = "%Y") +
  scale_color_viridis_d() +
  theme_minimal() +
  labs(x = element_blank(),
       col = "Updated?",
       y = "Dependencies",
       linetype = "Type of dependencies",
       title = "More dependencies lead to archive?",
       subtitle = "Packages dependencies, without base packages by date published on CRAN.") +
  theme(legend.position = c(0.3, 0.8))
```


The oldest packages on CRAN which were never updated have similar direct dependencies to those with archives but with more indirect dependencies.  
More recent packages have more direct dependencies and even more indirect dependencies. 
This can also lead to a different lecture, to avoid problems packages reduce their (direct) dependencies. 

Without knowing the history of dependencies of CRAN or what actually lead to being archived it might be hard to solve this question. 

### Date

When I asked online about more question Jonathan Carroll suggested to look up if we are using newer packages or more of the older ones:

```{r tweet-honathan, echo=FALSE}
blogdown::shortcode('tweet', '1533744129695330304')
```

First we need to exclude the base packages and then we look at the dependencies to see the first release date of the package:

```{r dependencies-dates}
dates_deps <- function(dependencies, dates, base_packages = NULL) {
  if (is.null(base_packages)) {
    base_packages <- rownames(installed.packages(priority = "base"))
  }
  deps <- dependencies[!dependencies %in% base_packages]
  d <- dates[deps]
  if (length(d) == 0) {
    return(data.frame(min = NA_Date_, median = NA_Date_, max = NA_Date_, n = 0))
  }
  data.frame(min = min(d, na.rm = TRUE), 
             median = median(d, na.rm = TRUE), 
             max = max(d, na.rm = TRUE),
             n = length(d))
}

first_release_dates <- all_packages2 |> 
  group_by(package) |> 
  summarise(date = min(date))
dates <- first_release_dates$date
names(dates) <- first_release_dates$package
l <- lapply(direct_dep, dates_deps, dates, base_packages)
# First date of release of a package and current date of publication of packages
deps_dates <- do.call("rbind", l) 
deps_dates$package <- names(direct_dep)
deps_dates <- left_join(deps_dates, packages2, 
                        by = c("package" = "Package")) |> 
  pivot_longer(cols = c(min, median, max))
```


```{r dependencies-dates-global}
deps_dates |> 
  filter(!is.na(value)) |> 
  ggplot() +
  geom_smooth(aes(date, value, weight = n, col = name))+
  geom_abline(slope = 1, intercept = 0) +
  labs(x = "Published date",
       y = "Dependencies date",
       title = "Min, median and max date of direct direct dependencies") +
  theme_minimal()
```


```{r dependencies-dates-weeks}
deps_dates |> 
  mutate(difftime = as.numeric(difftime(date, value, units = "weeks"))) |> 
  mutate(difftime = if_else(is.na(difftime), 0, difftime)) |> 
  ggplot() +
  geom_smooth(aes(date, difftime, col = name)) +
  geom_abline(slope = 1/52, intercept = 0) +
  scale_y_continuous(sec.axis = sec_axis( ~ ./52, 
                                          name = "Dependencies years of difference")) +
  scale_x_continuous(expand = expansion()) +
  labs(x = "Published date",
       y = "Dependencies weeks of difference",
       title = "Min, median and max date of direct dependencies") +
  theme_minimal()
```


```{r dependencies-dates-type}
deps_dates |> 
  mutate(difftime = as.numeric(difftime(date, value, units = "weeks"))) |> 
  ggplot() +
  geom_smooth(aes(date, difftime, col = name, linetype = yesno(with_archives))) +
  geom_abline(slope = 1/52, intercept = 0) +
  scale_y_continuous(sec.axis = sec_axis( ~ ./52, 
                                          name = "Dependencies years of difference")) +
  scale_x_date(expand = expansion()) +
  facet_wrap(~ifelse(with_archives, "New", "Already on CRAN"), scales = "free_x") +
  labs(x = "Published date",
       y = "Dependencies weeks of difference",
       linetype = "Already on CRAN?",
       col = "Dependencies date",
       title = "Min, median and max date of direct dependencies") +
  theme_minimal() +
  theme(panel.spacing = unit(1, "lines"))
```


There is around a median of 10 year gap between publishing a package and getting a package depending on it according to the first release of packages currently on CRAN.
At earliest there is a median of 6 year gap and sometimes dependencies are up to 16 years older than the new package.
For reference a new packages today depending, importing or enhancing dplyr, which first release was in 2014-01-29, is around 8 years and depending on the first packages on CRAN means at most 25 years of release differences.

If we take the dependency with the less difference on each day we see the earliest dependency tend to be 2 years after publication of the package.

```{r dependencies-dates-fastest}
deps_dates |> 
  mutate(difftime = as.numeric(difftime(date, value, units = "weeks"))) |> 
  filter(name == "max") |> 
  group_by(date, with_archives) |> 
  summarise(value = min(date, na.rm = TRUE),
            difftime = min(difftime, na.rm = TRUE)) |> 
  ungroup() |> 
  ggplot() +
  geom_smooth(aes(date, difftime, linetype = yesno(with_archives))) +
  geom_abline(slope = 1/52, intercept = 0) +
  scale_y_continuous(sec.axis = sec_axis( ~ ./52, 
                                          name = "Dependencies years of difference")) +
  scale_x_date(expand = expansion()) +
  # facet_wrap(~ifelse(with_archives, "New", "Already on CRAN"), scales = "free_x") +
  labs(x = "Published date",
       y = "Dependencies weeks of difference",
       linetype = "Already on CRAN?",
       col = "Dependencies date",
       title = "Min, median and max date of direct dependencies") +
  theme_minimal() +
  theme(panel.spacing = unit(1, "lines"), legend.position = c(0.3, 0.4))
```

So we can see that around 2018 there is a tendency to depend on new packages by newer packages.
This has gone from depending on packages 5 years older to depend on packages below 2 years. 
Some of the older packages also tend to depend on newer packages with the inflection point around 2019. 

The plots above are about the packages published that date.
It can be confusing but it is not the median time difference of the day.

### Looking by day


If we summaries the time difference we can do the difference by min value, max value and median.

<details><summary>If we take the minimum difference on each day:</summary>


```{r dependencies-day}
deps_dates |> 
  mutate(difftime = as.numeric(difftime(date, value, units = "weeks"))) |> 
  group_by(date, name, with_archives) |> 
  summarise(value = min(date, na.rm = TRUE),
            difftime = min(difftime, na.rm = TRUE)) |> 
  ungroup() |> 
  ggplot() +
  geom_smooth(aes(date, difftime, col = name, linetype = yesno(with_archives))) +
  geom_abline(slope = 1/52, intercept = 0) +
  scale_y_continuous(sec.axis = sec_axis( ~ ./52, 
                                          name = "Dependencies years of difference")) +
  scale_x_date(expand = expansion()) +
  facet_wrap(~ifelse(with_archives, "New", "Already on CRAN"), scales = "free_x") +
  # facet_zoom(x = date >= as.Date("2021/01/01"),
  #            xlim = c(as.Date("2021/01/01"), Sys.Date())) +
  labs(x = "Published date",
       y = "Dependencies weeks of difference",
       linetype = "Already on CRAN?",
       col = "Dependencies date",
       title = "Min, median and max date of direct dependencies") +
  theme_minimal() +
  theme(panel.spacing = unit(1, "lines"))
```
</details>

<details><summary>If we take the maximum difference on each day:</summary>


```{r dependencies-day2}
deps_dates |> 
  mutate(difftime = as.numeric(difftime(date, value, units = "weeks"))) |> 
  group_by(date, name, with_archives) |> 
  summarise(value = max(date, na.rm = TRUE),
            difftime = max(difftime, na.rm = TRUE)) |> 
  ungroup() |> 
  ggplot() +
  geom_smooth(aes(date, difftime, col = name, linetype = yesno(with_archives))) +
  geom_abline(slope = 1/52, intercept = 0) +
  scale_y_continuous(sec.axis = sec_axis( ~ ./52, 
                                          name = "Dependencies years of difference")) +
  scale_x_date(expand = expansion()) +
  facet_wrap(~ifelse(with_archives, "New", "Already on CRAN"), scales = "free_x") +
  # facet_zoom(x = date >= as.Date("2021/01/01"),
  #            xlim = c(as.Date("2021/01/01"), Sys.Date())) +
  labs(x = "Published date",
       y = "Dependencies weeks of difference",
       linetype = "Already on CRAN?",
       col = "Dependencies date",
       title = "Min, median and max date of direct dependencies") +
  theme_minimal() +
  theme(panel.spacing = unit(1, "lines"))
```

</details>

With the median daily difference:

```{r dependencies-day3}
deps_dates |> 
  mutate(difftime = as.numeric(difftime(date, value, units = "weeks"))) |> 
  group_by(date, name, with_archives) |> 
  summarise(value = median(date, na.rm = TRUE),
            difftime = median(difftime, na.rm = TRUE),
            n = n()) |> 
  ungroup() |> 
  ggplot() +
  geom_smooth(aes(date, difftime, col = name, linetype = yesno(with_archives),
                  weight = n)) +
  geom_abline(slope = 1/52, intercept = 0) +
  scale_y_continuous(sec.axis = sec_axis( ~ ./52, 
                                          name = "Dependencies years of difference")) +
  scale_x_date(expand = expansion()) +
  facet_wrap(~ifelse(with_archives, "New", "Already on CRAN"), scales = "free_x") +
  # facet_zoom(x = date >= as.Date("2021/01/01"),
  #            xlim = c(as.Date("2021/01/01"), Sys.Date())) +
  labs(x = "Published date",
       y = "Dependencies weeks of difference",
       linetype = "Already on CRAN?",
       col = "Dependencies date",
       title = "Daily time difference of direct dependencies") +
  theme_minimal() +
  theme(panel.spacing = unit(1, "lines"))
```

We can see that in 2012 new packages tended to depend on newer packages than now, while now they tend to depend around 12 years and close to 6 years at least.
Reminder that this is only for those with dependencies outside base packages.

Looking at the number of packages without dependencies we see a constant number.

```{r dependencies-dayd}
deps_dates |> 
  pivot_wider(names_from = name, values_from = value) |> 
  filter(n == 0) |> 
  count(date, with_archives) |> 
  ggplot() +
  geom_smooth(aes(date, n, 
                  col = yesno(!with_archives), linetype = yesno(!with_archives)),
              span = "1 month") +
  # facet_wrap(~with_archives, scales = "free") +
  scale_y_continuous(expand = expansion(add = c(NA_integer_, NA_integer_))) +
  scale_x_date(expand = expansion()) +
  labs(col = "New on CRAN?", linetype = "New on CRAN?", y = "Packages",
       title = "Packages without dependencies") +
  theme_minimal() +
  theme(legend.position = c(0.2, 0.7))
```



```{r dates-tables-summary, eval=FALSE, include=FALSE}
deps_dates |> 
  mutate(difftime = as.numeric(difftime(date, value, units = "weeks"))) |> 
  group_by(name) |>
  summarise(weeks = median(difftime, na.rm = TRUE),
            months = weeks/4,
            years = weeks/52) |> 
  ungroup()
deps_dates |> 
  mutate(difftime = as.numeric(difftime(date, value, units = "weeks"))) |> 
  group_by(with_archives, name) |>
  summarise(weeks = median(difftime, na.rm = TRUE),
            months = weeks/4,
            years = weeks/52) |> 
  ungroup()
```


## Future ideas


This is only using these files wihout cross checking with other information available about CRAN (like [PACKAGES.in](https://llrs.dev/post/2021/12/07/reasons-cran-archivals/) or [submission records](https://llrs.dev/post/2021/01/31/cran-review/)).
Using together all this data will provide a much complete picture and might help answer many more questions.
Like knowing the time between last submission and archival and/or checking the CRAN checks issues before archival.

Let me know if you explore this data with a different question or the same and you find something different/interesting!


### Reproducibility

<details><summary>Session Info</summary>

```{r reproducibility, echo = FALSE}
## Reproducibility info
sessioninfo::session_info()
```

</details>

