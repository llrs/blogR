---
title: 'Bioconductor submissions: reviews'
author: Llu√≠s Revilla Sancho
date: '2020-07-31'
slug: bioconductor-submissions-reviews
categories:
  - Bioconductor
  - r
tags:
  - Bioconductor
  - r
  - reviews
authors: []
description: 'Looking in detail to Bioconductor sumbissions: interactions between bots, reviewers and the community.'
editor_options:
  chunk_output_type: console
featured: no
draft: true
image:
  caption: ''
  focal_point: ''
subtitle: 'The second part of Bioconductor submissions'
summary: 'Looking in detail to Bioconductor sumbissions: interactions between bots, reviewers and the community.'
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, warning = FALSE, message = FALSE)
```

First post  is on [Bioconductor submissions](https://llrs.dev/2020/06/bioconductor-submissions/) raised some questions comments but at the time I didn't have a good way to answer them:

- issues get closed after they got assigned a reviewer and before the reviewer actually gets a chance to start the review.
- issues assigned to multiple people or issues that switched reviewers

To answer both of them I needed more information.
On the previous post I only gathered the information of the state of the issues at that moment. 
This excluded label changes, reviewer changes, renaming the issues, who commented on the issues and many more things.
To retrieve these information from github I developed a [new package](https://llrs.dev/2020/06/social-github/) [`{socialGH}`](https://github.com/llrs/socialGH) which downloads it from [Github](https://github.com) to make the analysis possible.

```{r reading}
library("socialGH")
repo <- "Bioconductor/Contributions"
gi <- get_issues(repo)
i <- unique(gi$id)
gt <- lapply(i, get_timelines, repository = repo)
saveRDS(gt, "static/2020083_timelines_Bioconductor_contributions.RDS")
gt <- readRDS("static/2020083_timelines_Bioconductor_contributions.RDS")
gt2 <- do.call(rbind, gt)
```

```{r prepare}
library("tidyverse")
theme_set(theme_minimal())
gi2 <- gi %>% 
  select(-n_comments) %>% 
  mutate(actor = poster, event = "created")

g <- rbind(gi2[, colnames(gt2)], gt2)
g2 <- g %>% 
  arrange(id, created) %>% 
  group_by(id) %>% 
  mutate(event_n = 1:n(),
         event = unlist(event, FALSE, FALSE),
         state = ifelse(event_n == 1, list("opened"), state))


i <- filter(g, event %in% c("merged", "committed"))
g2 <- filter(g2, !id %in% i$id) %>% 
  mutate(approved = any(vapply(label, 
                           function(x){"3a. accepted" %in% x}, logical(1L))),
         Approved = case_when(any(approved) ~ "Yes",
                              sum(event == "closed") >= sum(event == "reopen") ~ "No",
                              TRUE ~ "Ongoing"))
saveRDS(g2, file = "static/202008_github_data.RDS")
link_issue <- function(n) {
  paste0("[",n, "](https://github.com/Bioconductor/Contributions/issues/", n, 
         ")", collapse = ", ")
}
link_profile <- function(id) {
  paste0("[", id, "](https://github.com/", id, ")", collapse = ", ")
}
```

Now that we have more data about the issues we can plot them similarly to what we did on the previous post:

```{r first_plot}
# If not closed add the closing time of today
g2 <- readRDS("static/202008_github_data.RDS")
library("tidyverse")
theme_set(theme_minimal())
releases <- data.frame(release = paste0("3.", 3:12),
           date = as.POSIXct(c("2016/04/04", "2016/10/18", "2017/04/25", 
                            "2017/10/31", "2018/05/01", "2018/10/31", 
                            "2019/05/03", "2019/10/30", "2020/04/28",
                            "2020/10/01"), format = "%Y/%m/%d"),
           stringsAsFactors = FALSE)

scale_data <- scale_x_datetime(expand = expansion(add = 10), 
               limits = as.POSIXct(c("2016-06-01", "2020-06-10"), "%Y-%m-%d"))

cut <- 5
g2 %>% 
  ggplot() +
  geom_point(aes(created, id, col = fct_lump_n(event, cut),
                 shape = fct_lump_n(event, cut)), size = 0.5) + 
  geom_vline(xintercept = releases$date, col = "#1a81c2") + # Releases dates
  geom_text(data = releases, aes(x = date, y = c(rep(1200, 5), rep(300, 5)),
           label = release)) + # Release dates
  scale_data +
  labs(x = "Events", y = "Issue", col = "Type", shape = "Type",
       title = "Events on issues") +
  scale_color_viridis_d() +
  theme(legend.position = "bottom", legend.direction = "horizontal") + 
  guides(colour = guide_legend(nrow = 1), shape = guide_legend(nrow = 1))
```

We can see that sometimes the issues remained silent for several months and then had a high level of events, or a single one (closing).

Compare to the pervious version it is surprising to see that one of the earliest issues still gets new events. 
![](https://llrs.dev/post/2020-06-01-bioconductor-submissions.en_files/figure-html/eda-1.png)
Apparently [issue 51](https://github.com/Bioconductor/Contributions) is being used to test the Bioconductor builder. 

```{r exclude_testing}
g2 <- filter(g2, !id %in% c(1:5, 51, 587, 764, 1540, 1541))
```


```{r summarizing}
by_issue <- g2 %>% 
  summarize(open_time = difftime(max(created), min(created), units = unit),
            n = max(event_n), 
            id = unique(id),
            slope = n/as.numeric(open_time))
by_user
by_reviewer
by_event
```


# Events

Looking a bit further on the issues we can look at the events that take place:

```{r second_plot}
g2 %>% 
  filter(event != "created") %>% 
  count(event) %>% 
  ungroup() %>% 
  arrange(id, event, n) %>% 
  ggplot() +
  geom_tile(aes(id, fct_reorder(event, n, .fun = sum), col = n)) +
  scale_color_continuous(expand = expansion(), trans = "log10", 
                         high = "#132B43", low = "#56B1F7") +
  # theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = element_blank(), x = "Issue", title = "Events per issue", col = "Times")
```

We can see that most issues have few events which agrees with the previous findings that issues are handled fairly and expeditiously.
The most common event are comments mentions and the rarest events are deleting comments, locking or referencing them. 

```{r events_time}
unit <- "days"
g2 %>% 
  group_by(id) %>% 
  filter(event_n == max(event_n)) %>% 
  ungroup() %>% 
  ggplot() +
  geom_histogram(aes(event_n), bins = 40) +
  labs(x = "Events", y = "Issues", title = "Events per issue")
diff_time <- g2 %>% 
  group_by(id) %>% 
  summarise(open_time = difftime(max(created), min(created), units = unit),
            n = max(event_n), 
            id = unique(id),
            slope = n/as.numeric(open_time)) %>% 
  ungroup()
diff_time %>%   
  ggplot() +
  geom_point(aes(open_time, n, col = slope)) +
  scale_color_continuous(expand = expansion(), trans = "log10",
                         high = "#132B43", low = "#56B1F7") +
  labs(y = "Events", x = glue::glue("Time open ({unit})"), 
       col = glue::glue("Events per {unit}"), 
       title = "Number of events and time open") +
  scale_x_continuous(breaks = 1:7*365, labels = function(x) {paste(x/365, "year")}) +
  theme(axis.text.x = element_text())

diff_time %>% 
  filter(open_time <= median(diff_time$open_time)) %>% 
  ggplot() +
  geom_point(aes(open_time, n, col = slope)) +
  scale_color_continuous(expand = expansion(), trans = "log10", 
                         high = "#132B43", low = "#56B1F7") +
  labs(y = "Events", 
       x = glue::glue("Time open ({unit})"), 
       col = glue::glue("Events per {unit}"), 
       title = "Number of events and time open",
       subtitle = "A zoom to the fastest half") +
  scale_x_continuous(breaks = 1:7*7, labels = function(x) {paste(x/7, "weeks")}) +
  theme(axis.text.x = element_text())
```

Some submissions have events l
Check that the opening and closing doesn't affect this...
We can see that in a short amount of days a lot of events can be triggered.

```{r assignments}
get_element <- function(x, name) {
  if (!is.null(names(x))) {
    getElement(x, name)
  } else {
    NA_character_
  }
} 

who <- g2 %>% 
  mutate(reviewer = vapply(assignee, get_element, name = "user", character(1)),
         actor = vapply(actor, get_element, name = "user", character(1L)),
         assignments = sum(event %in% "assigned"),
         reviewers = assignments - sum(event %in% "unassigned"))

assignments <- who %>% 
  filter(event %in% c("assigned", "unassigned", "commented", "created", "closed"))

assignments %>% 
  summarise(reasigned  = any(event %in% "unassigned"),
            assignments = unique(assignments),
            reviewers = unique(reviewers),
            Approved = unique(Approved)) %>% 
  ggplot() +
  geom_count(aes(reviewers, assignments, col = reasigned, shape = reasigned)) +
  labs(x = "Final reviewers", y = "Assigned", title = "Reviewers", 
       col = "Reassigned?", shape = "Reassigned?", size = "Submissions") +
  scale_color_brewer(labels = c("No", "Yes"), type = "qual") +
  scale_shape(labels = c("No", "Yes")) +
  scale_size(trans = "log10")
```

We can see that usually some adjustment to reviewers is made usually changing them but some times they are added to have more than 1 reviewer (41 submissions).
Almost all the submitted packages without a reviewer (533 submissions) were rejected except for three: `r link_issue(81:83)` that were reviewed by `r link_profile(vobencha)` even if not officially assigned.
Some of these were rejected because they didn't pass some automatic check and other after preliminary inspection.

```{r time}
trelative <- function(x) {
  created <- x$created
  event <- x$event
  start <- created[event == "created"]
  k <- event == "closed"
  if (any(k)){
    closing <- created[which.max(k)]
  } else {
    closing <- max(created)
  }
  
  o <- difftime(created[!is.na(created)], start, units = "days")
  as.numeric(o)
}

relative_time <- assignments %>%
  nest_by() %>% 
  summarize(t = trelative(data), created = data$created) %>% 
  inner_join(assignments)
```

```{r submission_acceptance, fig.cap="Submissions with a reviewer assigned that were closed by someone (not the submitter)."}
revi <- relative_time %>% 
  filter(reviewers == 1) %>% 
  summarise(reviewer = last(reviewer[!is.na(reviewer)]),
         reviewer_commented = any(event[actor %in% reviewer] == "commented"),
         id = unique(id),
         Approved = unique(Approved),
         closer = last(actor[event == "closed"]),
         creator = unique(actor[event == "created"])) 

reviwer_didnt_close <- revi %>% 
  filter(!is.na(closer),
         closer != reviewer & Approved == "No") %>% 
  pull(id)

author_closed <- revi %>% 
  filter(!is.na(closer), closer == creator) %>% 
  pull(id)

revi_sum <- revi %>% 
  filter(!id %in% author_closed) %>% 
  group_by(reviewer, reviewer_commented, Approved) %>% 
  count() %>% 
  group_by(reviewer) %>% 
  mutate(perc = n/sum(n)) %>% 
  arrange(reviewer, reviewer_commented, Approved)

ord_rev <- revi_sum %>% 
  summarise(total = sum(n)) %>% 
  arrange(-total) %>% 
  pull(reviewer) %>% .[1:8]

r <- revi_sum %>% 
  mutate(reviewer_commented = ifelse(reviewer_commented, "commented", "not commented"),
         Approved = ifelse(Approved == "Yes", "Approved", "Rejected"),
         reviewer = as.factor(reviewer)) %>% 
  filter(reviewer %in% ord_rev) %>% 
  mutate(reviewer = fct_drop(reviewer)) %>% 
  mutate(reviewer = fct_relevel(reviewer, !!!ord_rev)) %>% 
  ungroup() %>% 
  nest_by(Approved, reviewer_commented) %>% 
  mutate(plot_relative = list(
    ggplot(data) +
      geom_col(aes(reviewer, perc)) +
      labs(title = paste(Approved, reviewer_commented), x = element_blank(), y = "Percentage") +
      scale_y_continuous(labels = scales::percent) +
      scale_x_discrete(drop = FALSE) +
      scale_fill_brewer(type =  "qual") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) ),
    plot_abs = list(
    ggplot(data) +
      geom_col(aes(reviewer, n)) +
      labs(title = paste(Approved, reviewer_commented), x = element_blank(), y = "Issues") +
      scale_x_discrete(drop = FALSE) +
      scale_fill_brewer(type =  "qual") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) ))
library("patchwork")

r$plot_relative[[1]] <- r$plot_relative[[1]] + theme(axis.text.x = element_blank())
r$plot_relative[[2]] <- r$plot_relative[[2]] + theme(axis.text.x = element_blank())
r$plot_relative[[2]] <- r$plot_relative[[2]] + labs(y = element_blank())
r$plot_relative[[4]] <- r$plot_relative[[4]] + labs(y = element_blank())
ptch <- wrap_plots(r$plot_relative)
ptch  

r$plot_abs[[1]] <- r$plot_abs[[1]] + theme(axis.text.x = element_blank())
r$plot_abs[[2]] <- r$plot_abs[[2]] + theme(axis.text.x = element_blank())
r$plot_abs[[2]] <- r$plot_abs[[2]] + labs(y = element_blank())
r$plot_abs[[4]] <- r$plot_abs[[4]] + labs(y = element_blank())
ptch2 <- wrap_plots(r$plot_abs)
ptch2 
```

We can see that the percentage of approved on those issues where the reviewer commented is fairly similar and around 80% or above. 
However there is also at least a 5% of submissions that are closed despite the comments from reviewers.
Usually this has to be with unresponsiveness from the submitter:

```{r events_days}
relative_time %>% 
  ggplot() +
  geom_line(aes(t, event_n, col = id, group = id)) +
  facet_wrap(~Approved) +
  labs(title = "Events along time", subtitle = "Approved?",
       x = "Days", y = element_blank())
```

We can see that on the approved packages there are usually more events on the same time period.
So make sure to follow the advice of the reviewers and the bot and make all the errors and warnings disappear. 

```{r events_user_distribution}
who_what <- who %>% 
  group_by(id) %>% 
  summarise(diff_events = n_distinct(event), 
         diff_actors = n_distinct(actor),
         events = n())

ggplot(who_what) +
  geom_bar(aes(as.factor(diff_events))) +
  labs(y = "Issues", x = element_blank(), 
       title = "Different events in the issue")
ggplot(who_what) +
  geom_bar(aes(as.factor(diff_actors))) +
  labs(y = "Issues", x = element_blank(), 
       title = "Different users involved in the issue")
```

While most issues have at least 8 different events they usually have 4 users involved.
Presumably the creator of the issue, bioc-issue-bot, a reviewer and someone else. 

```{r actor_event_types}
who_what %>% 
  mutate(diff_actors = factor(diff_actors, levels = 1:13)) %>% 
  ggplot() +
  geom_count(aes(diff_actors, as.factor(diff_events))) +
  labs(x = "Users", y = "Events", title = "Users involved and type of events",
       size = "Issues") +
  scale_x_discrete(drop = FALSE) 
```

The more users involved, more different type of events are triggered.
Presumably more people get subscribed or is mentioned. 

```{r actors_events}
who_what %>% 
  mutate(diff_actors = factor(diff_actors, levels = 1:13)) %>% 
  group_by(diff_actors) %>% 
  count(events) %>% 
  ggplot() +
  geom_jitter(aes(as.factor(diff_actors), events, size = n), 
             height = 0) +
  labs(x = "Users", y = "Events", size = "Issues",
       title = "Users involved on the issues and events") +
  scale_x_discrete(drop = FALSE) + 
  scale_size(breaks = c(seq(0, 300, by = 50)))
# TODO color by approved? Or somthing like that
```

As expected the more users are involved in an issue more events are produced.

# Who does each action ?

We can look now at who performs what, we know there are `r n_distinct(who$actor)` participants:

```{r who}
who %>% 
  group_by(event, actor, .add = FALSE) %>% 
  count(sort = TRUE) %>% 
  filter(n > 30) %>% 
  ggplot() + 
  geom_tile(aes(fct_reorder2(event, -n, actor), 
                fct_reorder(actor, n, .fun = sum), 
                fill = n)) +
  scale_fill_viridis_c(trans = "log10", expand = expansion()) +
  labs(title = "Events by users", y = element_blank(), x = element_blank())
```

Here I cut at people who have triggered more than 30 events. 
We can clearly see who are official reviewers (as seen on the previous post) because they labeled and unlabeled issues.
bioc-issue-bot is an special user that makes lots of comments and assigning reviewers to issues.


```{r}
comments <- who %>% 
  mutate(n = sum(event %in% "assigned"),
         reasigned  = any(event %in% "unassigned"),
         reviewers = n - sum(event %in% "unassigned"),
         creator = unique(actor[event == "created"]),
         reviewer = last(reviewer[!is.na(reviewer)])) %>% 
  filter(actor != "bioc-issue-bot", event == "commented", reviewers == 1) %>% 
  group_by(id) %>% 
  summarise(speaking = n_distinct(actor), 
            comments = n(), 
            reviewer = sum(actor == reviewer),
            author = sum(actor == creator),
            mtmorgan = sum(actor == "mtmorgan"),
            other = comments - reviewer - author)
comments %>% 
  ggplot() +
  geom_count(aes(author, reviewer)) +
  labs(title = "Comments", x = "Authors", y = "Reviewer", size = "Issues")
```

Comments by users, usually only the author, the reviewer comment, frequently mtmorgan also suggests. 

```{r}
comments %>% 
  filter(mtmorgan != reviewer) %>% 
  mutate(perc = mtmorgan/other) %>% 
  ggplot() +
  geom_count(aes(other, mtmorgan, col = perc)) +
  geom_abline(slope = 1, intercept = 0) +
  labs(title = "Other comments compared to mtmorgan", x = "Other", 
       size = "Issues", col = "Ratio") +
  scale_y_continuous(breaks = seq(0, 13, by = 2)) +
  scale_radius()
```

We can see that Martin Morgan has commented on almost all the submissions. 
The odd issue where there are some comments from mtmorgan but no other is the [issue 611](https://github.com/Bioconductor.org/Contributions/issue/611) where he is the reviewer and the submitter of a package.

# Bioconductor Bot

We have seen that one of the most relevant "users" is bioc-issue-bot.  
It is a bot that performs and report automatic checks on the submissions (The code can be found [here](https://github.com/Bioconductor/issue_tracker_github)). 
Let's explore what does and what does it report

```{r bioc_bot_plot}
bioc_bot <- who %>% 
  filter(actor == "bioc-issue-bot" & event == "commented") %>% 
  mutate(reason = case_when(
    startsWith(text, "Hi @") ~ "Received",
    startsWith(text, "Received a valid push") ~ "Valid push",
    str_detect(text, "^(\n)?Dear Package contributor,") ~ "Build result",
    startsWith(text, "A reviewer has been assigned to your package") ~ "Reviewer assigned",
    str_detect(text, "There is no repository called") ~ "Missing repository",
    str_detect(text, "Thanks for submitting your additional package") ~ "Additional package",
    str_detect(text, "has already posted ") ~ "repost",
    str_detect(text, "for an extended period of time") ~ "Closing",
    str_detect(text, "DESCRIPTION file") ~ "Unmatch",
    str_detect(text, "Your package has been approved for building") ~ "Building",
    str_detect(text, "We only start builds when the `Version`") ~ "Update version",
    str_detect(text, "a GitHub repository URL") ~ "Missing repository",
    str_detect(text, "more than one GitHub URL") ~ "Multiple repositories",
    str_detect(text, "Add SSH keys") ~ "SSH key",
    startsWith(text, "Your package has been accepted.") ~ "Accepted",
    TRUE ~ "Other"
  ))
cm <- bioc_bot %>% 
  group_by(id) %>% 
  count(reason, sort = TRUE) %>% 
  ungroup()
cm %>% 
  ggplot() +
  geom_tile(aes(id, fct_reorder(reason, n, .fun = sum), col = n)) +
  scale_color_viridis_c(trans = "log10", expand = expansion()) +
  labs(x = "Issue", title = "Automated comments from bioc-issue-bot", 
       y = element_blank())
```

Classifying the comments reports that most of the comments are build results or that received a valid push. 
We can also see some changes on the bot, like changing the messages or reporting differently the process triggered. 
However, it also reports common problems on the submission: missing repository, unmatch between the repository name and the package name, reposting the same package, missing SSH key (needed to be able to push to Bioconductor git server), ...

```{r}
cm %>% 
  group_by(id) %>% 
  summarise(n = sum(n)) %>% 
  ggplot() +
  geom_point(aes(id, n)) 
cm %>% 
  group_by(id) %>% 
  mutate(perc = n/sum(n)) %>% 
  ggplot() +
  geom_col(aes(id, perc, fill = fct_lump_n(reason, 7), group = reason),
           width = 1) +
  labs(fill = "Type of comment", y = element_blank(), x = element_blank(),
       title = "Comments on issues") +
  scale_fill_brewer(type = "qual") +
  scale_y_continuous(labels = scales::percent)
```

We can see that most of them are valid pushes and build results. 

More or less the Bioc-issue-bot posts the same number of comments along issues.

```{r}
bm <- bioc_bot %>% 
  group_by(id) %>% 
  count(reason) %>% 
  mutate(total = sum(n)
            )
build_related <- c("Build result", "Building", "Valid push", "Received")
build_bot <- bm %>% 
  filter(reason %in% build_related) %>% 
  summarise(total = unique(total),
            builds = sum(n))
build_bot %>% 
  filter(builds != 0) %>% 
  ggplot() +
  geom_count(aes(total, builds)) +
  labs(x = "Comments", y = "Build related comments",
       title = "bioc-issue-bot", size = "Issues") +
  scale_radius()
```

Comments of bioc-issue-bot are driven by the build system.

```{r common_feedback}
issues_not_build <- build_bot %>% 
  filter(builds/total < 0.75) %>% 
  pull(id)
bm %>% 
  filter(id %in% issues_not_build,
         !reason %in% build_related) %>% 
  ungroup() %>% 
  group_by(reason) %>% 
  summarise(n = sum(n)) %>% 
  arrange(-n)
```

But when not it is mainly that there's need to update the version of the package, that it was inactive, is already posted in another issue or couldn't find the repository.

### Reproducibility

<details>
```{r reproducibility, echo = FALSE}
## Reproducibility info
options(width = 120)
sessioninfo::session_info()
```
</details>
