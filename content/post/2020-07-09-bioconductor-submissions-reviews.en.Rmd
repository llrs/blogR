---
title: 'Bioconductor submissions: reviews'
author: Llu√≠s Revilla Sancho
date: '2020-07-31'
slug: bioconductor-submissions-reviews
categories:
  - Bioconductor
  - r
tags:
  - Bioconductor
  - r
  - reviews
authors: []
description: 'Looking in detail to Bioconductor sumbissions: interactions between bots, reviewers and the community.'
editor_options:
  chunk_output_type: console
featured: no
draft: true
image:
  caption: ''
  focal_point: ''
subtitle: 'The second part of Bioconductor submissions'
summary: 'Looking in detail to Bioconductor sumbissions: interactions between bots, reviewers and the community.'
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, warning = FALSE, message = FALSE)
```

First post  is on [Bioconductor submissions](https://llrs.dev/2020/06/bioconductor-submissions/) raised some questions comments but at the time I didn't have a good way to answer them:

- issues get closed after they got assigned a reviewer and before the reviewer actually gets a chance to start the review.
- issues assigned to multiple people or issues that switched reviewers

The common problem is that I didn't have the information available. 
On the previous post I only gathered the information of the state of the issues at that moment. 
This excluded label changes, reviewer changes, renaming the issues, who commented on the issues and many more things.
To retrieve these information from github I developed a [new package](https://llrs.dev/2020/06/social-github/) which downloads it from [Github](https://github.com) to make the analysis possible.

```{r reading}
library("socialGH")
repo <- "Bioconductor/Contributions"
gi <- get_issues(repo)
i <- unique(gi$id)
gt <- lapply(i, get_timelines, repository = repo)
saveRDS(gt, "static/20200718_timelines_Bioconductor_contributions.RDS")
gt <- readRDS("static/20200718_timelines_Bioconductor_contributions.RDS")
gt2 <- do.call(rbind, gt)
```

```{r prepare}
library("tidyverse")
library("stringr")
theme_set(theme_minimal())
gi2 <- gi %>% 
  select(-n_comments) %>% 
  mutate(actor = poster, event = "created")

g <- rbind(gi2[, colnames(gt2)], gt2)
g2 <- g %>% 
  arrange(id, created) %>% 
  group_by(id) %>% 
  mutate(event_n = 1:n(),
         event = unlist(event, FALSE, FALSE),
         state = ifelse(event_n == 1, list("opened"), state))

i <- filter(g, event %in% c("merged", "committed"))
g2 <- filter(g2, !id %in% i$id) %>% 
  mutate(approved = any(vapply(label, 
                           function(x){"3a. accepted" %in% x}, logical(1L))),
         Approved = case_when(any(approved) ~ "Yes",
                              sum(event == "closed") >= sum(event == "reopen") ~ "No",
                              TRUE ~ "Ongoing"))
```

Now that we have more data about the issues we can plot them similarly to what we did on the previous post:

```{r first_plot}

# If not closed add the closing time of today
releases <- data.frame(release = paste0("3.", 3:12),
           date = as.POSIXct(c("2016/04/04", "2016/10/18", "2017/04/25", 
                            "2017/10/31", "2018/05/01", "2018/10/31", 
                            "2019/05/03", "2019/10/30", "2020/04/28",
                            "2020/10/01"), format = "%Y/%m/%d"),
           stringsAsFactors = FALSE)

scale_data <- scale_x_datetime(expand = expansion(add = 10), 
               limits = as.POSIXct(c("2016-06-01", "2020-06-10"), "%Y-%m-%d"))

cut <- 1239
g2 %>% 
  ggplot() +
  geom_point(aes(created, id, col = fct_lump_min(event, cut),
                 shape = fct_lump_min(event, cut)), size = 0.5) + 
  geom_vline(xintercept = releases$date, col = "#1a81c2") + # Releases dates
  geom_text(data = releases, aes(x = date, y = c(rep(1200, 5), rep(300, 5)),
           label = release)) + # Release dates
  scale_data +
  labs(x = "Events", y = "Issue", col = "Type", shape = "Type",
       title = "Events on issues") +
  scale_color_viridis_d() +
  theme(legend.position = "bottom", legend.direction = "horizontal") + 
  guides(colour = guide_legend(nrow = 1), shape = guide_legend(nrow = 1))
```

We can see that sometimes the issues remained silent for several months and then had a high level of events, or a single one (closing).


# Events

Looking a bit further on the issues we can look at the events that take place:

```{r second_plot}
g2 %>% 
  filter(event != "created") %>% 
  count(event) %>% 
  ungroup() %>% 
  arrange(id, event, n) %>% 
  ggplot() +
  geom_tile(aes(event, id, col = n)) +
  scale_color_continuous(expand = expansion(), trans = "log10", 
                         high = "#132B43", low = "#56B1F7") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = element_blank(), y = "Issue", title = "Events per issue", col = "Times")
```

We can see that most issues have few events which agrees with the previous findings that issues are handled fairly and expeditiously.
Also there are some events rarely used as comment deleted, locked or referenced. 

```{r events_time}
unit <- "days"
g2 %>% 
  group_by(id) %>% 
  filter(event_n == max(event_n)) %>% 
  ungroup() %>% 
  ggplot() +
  geom_histogram(aes(event_n)) +
  labs(x = "Events", y = "Issues", title = "Events per issue")
diff_time <- g2 %>% 
  group_by(id) %>% 
  summarise(open_time = difftime(max(created), min(created), units = unit),
            n = max(event_n), 
            id = unique(id),
            slope = n/as.numeric(open_time)) %>% 
  ungroup()
diff_time %>%   
  ggplot() +
  geom_point(aes(open_time, n, col = slope)) +
  scale_color_continuous(expand = expansion(), trans = "log10",
                         high = "#132B43", low = "#56B1F7") +
  labs(y = "Events", x = glue::glue("Time open ({unit})"), 
       col = glue::glue("Events per {unit}"), 
       title = "Number of events and time open")

diff_time %>% 
  filter(open_time <= median(diff_time$open_time)) %>% 
  ggplot() +
  geom_point(aes(open_time, n, col = slope)) +
  scale_color_continuous(expand = expansion(), trans = "log10", 
                         high = "#132B43", low = "#56B1F7") +
  labs(y = "Events", 
       x = glue::glue("Time open ({unit})"), 
       col = glue::glue("Events per {unit}"), 
       title = "Number of events and time open",
       subtitle = "A zoom to the fastest half")
```


```{r}
assigned <- g2 %>% 
  filter(event %in% c("assigned", "unassigned")) %>% 
  mutate(reviewer = lapply(assignee, getElement, name = "user"))
  mutate(n_rev = dim(data$assignee)) %>% 
  group_by(id)
  mutate(n = n(), 
         multiple = n_distinct(event) != 1) %>% 
  select(id, event, multiple, n, n_rev)
```


# Who does each action ?

```{r who}
g3 <- g2 %>% 
  filter(!event %in% c("mentioned", "subscribed", "renamed", "closed")) %>% 
  mutate(actor = vapply(actor, getElement, name = "user", character(1L)))
```

We can look now at who performs what, we know there are `r n_distinct(g3$actor)` participants:

```{r who}
g3 %>% 
  group_by(event, actor, .add = FALSE) %>% 
  count(sort = TRUE) %>% 
  filter(n > 30 & n_distinct(id) >= 2) %>% # Error check out this
  ggplot() + 
  geom_tile(aes(fct_reorder2(event, -n, actor), 
                fct_reorder(actor, n, .fun = sum), 
                fill = n)) +
  scale_fill_viridis_c(trans = "log10", expand = expansion()) +
  labs(title = "Events by users", y = element_blank(), x = element_blank())
g3 %>% 
  filter(actor != "bioc-issue-bot") %>% 
  group_by(event, actor, .add = FALSE) %>% 
  count(sort = TRUE) %>% 
  filter(n > 30) %>% 
  ggplot() + 
  geom_tile(aes(fct_reorder2(event, -n, actor), 
                fct_reorder(actor, n, .fun = sum), 
                fill = n)) +
  scale_fill_viridis_c(trans = "log10", expand = expansion()) +
  labs(title = "Events by users", y = element_blank(), x = element_blank())
```

# Bioconductor Bot

We have seen that one of the most relevant "users" is bioc-issue-bot. 
Let's explore what does and how does it help

```{r}
bioc_bot <- g3 %>% 
  filter(actor == "bioc-issue-bot" & event == "commented") %>% 
  mutate(reason = case_when(
    startsWith(text, "Hi @") ~ "Received",
    startsWith(text, "Received a valid push") ~ "Valid push",
    str_detect(text, "^(\n)?Dear Package contributor,") ~ "Build result",
    startsWith(text, "A reviewer has been assigned to your package") ~ "Reviewer assigned",
    str_detect(text, "There is no repository called") ~ "Missing repository",
    str_detect(text, "Thanks for submitting your additional package") ~ "Additional package",
    str_detect(text, "has already posted ") ~ "repost",
    str_detect(text, "for an extended period of time") ~ "Closing",
    str_detect(text, "DESCRIPTION file") ~ "Unmatch",
    str_detect(text, "Your package has been approved for building") ~ "Building",
    str_detect(text, "We only start builds when the `Version`") ~ "Update version",
    str_detect(text, "a GitHub repository URL") ~ "Missing repository",
    str_detect(text, "more than one GitHub URL") ~ "Multiple repositories",
    str_detect(text, "Add SSH keys") ~ "SSH key",
    startsWith(text, "Your package has been accepted.") ~ "Accepted",
    TRUE ~ "Other"
  ))
sort(table(bioc_bot$reason))
s <- bioc_bot %>% filter(reason == "Other") %>% pull(text)
cm <- bioc_bot %>% 
  group_by(id) %>% 
  count(reason, sort = TRUE) %>% 
  ungroup()
cm %>% 
  ggplot() +
  geom_bar(aes(id, fill = fct_lump_n(reason, 7, w = n), weight = n)) +
  scale_fill_brewer(type = "qual")
cm %>% 
  ggplot() +
  geom_tile(aes(id, fct_reorder(reason, n, .fun = sum), col = n)) +
  scale_color_viridis_c(trans = "log10", expand = expansion())
```


```{r}
cm %>% 
  group_by(id) %>% 
  summarise(n = sum(n)) %>% 
  ggplot() +
  geom_point(aes(id, n)) +
  coord_cartesian(ylim = c(0, 200)) +
  geom_smooth(aes(id, n), method = "lm")
cm %>% 
  ggplot() +
  geom_point(aes(id, n, col = reason, group = reason)) +
  coord_cartesian(ylim = c(0, 200)) +
  geom_smooth(aes(id, n), method = "lm")
```

More or less the Bioc-issue-bot posts the same number of comments along issues.

```{r}
bm <- bioc_bot %>% 
  group_by(id) %>% 
  summarise(valid_push = sum(valid_push), 
            build = sum(build), 
            no_repo = sum(no_repo), 
            additional_pkg = sum(additional_pkg),
            repost = sum(repost),
            auto_close = sum(auto_close),
            no_desc = sum(no_desc),
            n = n(),
            n_out = n - valid_push - build - no_repo - additional_pkg - repost - auto_close - no_desc
            )
bm %>% 
  ggplot() +
  geom_point(aes(valid_push, build, col = n_out))
```



## Reviewers


## Outsiders?

```{r}
g2 %>% 
  mutate(assigned = map(assignee, function(x) {
    ifelse(!is.null(unlist(x, FALSE, FALSE)), 
                  getElement(x, "user"), 
                  NA_character_)
  })
           ) %>% 
  select(assigned, id)
  group_by(id) %>% 
  filter(any(!is.na(assigned))) %>% 
  head()

k <- g2 %>% mutate(k == map2(actor, poster, function(x, y) {
  print(is(x))v
  print(is(y))
  nrow(x) == nrow(y)
})) %>% pull(k)

```


### Reproducibility

<details>
```{r reproducibility, echo = FALSE}
## Reproducibility info
options(width = 120)
sessioninfo::session_info()
```
</details>
