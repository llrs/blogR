---
title: CRAN maintained packages
author: Llu√≠s Revilla Sancho
date: '2023-05-03'
slug: cran-maintained-packages
categories:
  - CRAN
tags:
  - CRAN
  - packages
authors:
  - admin
description: ''
draft: no
editor_options:
  chunk_output_type: console
featured: no
image:
  caption: ''
  focal_point: ''
subtitle: ''
summary: ''
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, fig.retina = 2, message = FALSE)
library("knitr")
knit_print.data.frame = function(x, ...) {
  res = paste(c('', '', kable(x)), collapse = '\n')
  asis_output(res)
}
knit_print.tbl_df = function(x, ...) {
  res = paste(c('', '', kable(x)), collapse = '\n')
  asis_output(res)
}
knit_print.matrix = function(x, ...) {
  res = paste(c('', '', kable(as.data.frame(x))), collapse = '\n')
  asis_output(res)
}
# register the method
registerS3method("knit_print", "data.frame", knit_print.data.frame)
registerS3method("knit_print", "tbl_df", knit_print.tbl_df)
registerS3method("knit_print", "matrix", knit_print.matrix)
```

The role of package managers in software is paramount for developers. 
In R the CRAN team provides a platform to tests and host packages. 
This means ensuring that R dependencies are up to date and software required by some packages are also available in CRAN.

This helps testing ~20000 packages frequently (daily for most packages) in several architectures and R versions.
In addition, they test updates for compatibility with the dependencies and test and review new packages.

Most of the work with packages is automated but often requires human intervention ([50% of the submisions](https://journal.r-project.org/news/RJ-2022-4-cran/#cran-package-submissions)). 
Another consuming activity is keeping up packages abandoned by their original maintainers. 

While newer packages are [archived from CRAN often](https://llrs.dev/post/2021/12/07/reasons-cran-archivals/), some old packages were adopted by CRAN.
The [CRAN team](https://cran.r-project.org/CRAN_team.htm) is [looking for help](https://mastodon.social/@henrikbengtsson/110186925898457474) maintining those.

In this post I'll explore the packages maintained by CRAN.

# CRAN in packages 

```{r cran_authors}
packages_db <- as.data.frame(tools::CRAN_package_db())
p <- grep("CRAN Team", x = packages_db$Author, ignore.case = TRUE)
p2 <- grep("CRAN Team", x = packages_db$`Authors@R`, ignore.case = TRUE)
CRAN_TEAM_mentioned <- union(p, p2)
unique(packages_db$Package[CRAN_TEAM_mentioned])
```

In some of these package the CRAN team appears as contributors because they provided help/code to fix bugs: 

- [geiger](https://cran.r-project.org/package=geiger)
- [fMultivar](https://cran.r-project.org/package=fMultivar)
- [fBasics](https://cran.r-project.org/package=fBasics) 
- [udunits2](https://cran.r-project.org/package=udunits2)

In others they are the maintainers: 

- [XML](https://cran.r-project.org/package=XML) 
- [RCurl](https://cran.r-project.org/package=RCurl) 
- [RJSONIO](https://cran.r-project.org/package=RJSONIO) 

From these three packages RJSONIO is the newest ( first release in 2010) and requires less updates (lately 1 or 2 a year). 
However, in 2022 RCurl and XML required 4 and 5 updates respectively.
I will focus on these packages as these are the ones they are looking for new maintainers.


# RCurl and XML

## Relevant data

Both packages have some system dependencies which might make the maintenance harder.
In addition they have a large number of dependencies:

```{r deps}
library("tools")
# Look up only software dependencies in Bioconductor
options(repos = BiocManager::repositories()[c("BioCsoft", "CRAN")])
ap <- available.packages()
all_deps <- package_dependencies(c("RCurl", "XML"), 
                                 reverse = TRUE, db = ap, which = "all")
all_unique_deps <- unique(unlist(all_deps, FALSE, FALSE))
first_deps <- package_dependencies(all_unique_deps, db = ap, which = "all")
first_deps_strong <- package_dependencies(all_unique_deps, db = ap, which = "strong")
strong <- sapply(first_deps_strong, function(x){any(c("XML", "RCurl") %in% x)})
first_rdeps <- package_dependencies(all_unique_deps, 
                                   reverse = TRUE, db = ap, which = "all")
deps_all <- package_dependencies(all_unique_deps, recursive = TRUE, 
                                 db = ap, which = "all")
```

They have `r length(all_unique_deps)` direct dependencies (and 8 more in annotation packages in Bioconductor: recount3, ENCODExplorerData, UCSCRepeatMasker, gDNAinRNAseqData, qdap, qdapTools, metaboliteIDmapping and curatedBreastData). 

With their dependencies there are around 20000 packages that depend on these two packages (about 90% of CRAN and Bioconductor)!

To focus on which packages are direct dependencies and help what is the best action, let's gather more information about them.
First the releases and dates. 
We can prioritze working with maintainers that are known to be active.

```{r releases}
archive <- tools:::CRAN_archive_db()[all_unique_deps]
packages <- tools::CRAN_package_db()
library("dplyr")
library("BiocPkgTools")
fr <- vapply(archive, function(x) {
  if (is.null(x)) {
    return(NA)
  }
  as.Date(x$mtime[1])
}, FUN.VALUE = Sys.Date())
fr_bioc <- biocDownloadStats() |> 
  filter(Package %in% all_unique_deps) |> 
  firstInBioc() |> 
  pull(Date, name = Package)
first_release <- c(as.Date(fr[!is.na(fr)]), as.Date(fr_bioc))[all_unique_deps]
last_update <- packages$Published[match(all_unique_deps, packages$Package)]
releases <- vapply(archive, NROW, numeric(1L)) + 1
maintainers <- packages_db$Maintainer[match(all_unique_deps, packages_db$Package)]
maintainers <- trimws(gsub("<.+>", "", maintainers))
```


We only have information about CRAN packages.
Bioconductor has two releases every year.
Even if maintainers didn't modify the package the version number increases (this is to make it easier to know which Bioconductor version they are from).
The patch releases in between are not tracked (they are still available in the [git server](https://code.bioconductor.org)).
But the verison update in the git doesn't propagate to users automatically unless their checks pass. 
For all these reasons it doesn't make sense to count releases of Bioconductor. 


We also retrieved the maintainers of CRAN packages to know key people to address to.
Note: the `maintainer` function only works for installed packages .


Another value we can use are the downloads from users of said pacakges.

```{r downloads}
library("cranlogs")
acd <- cran_downloads(intersect(all_unique_deps, packages_db$Package), 
                          when = "last-month")
cran_pkg <- summarise(acd, downloads = sum(count), .by = package)
loc <- Sys.setlocale(locale = "C")
bioc_d <- vapply(setdiff(all_unique_deps, packages_db$Package), function(x){
  pkg <- pkgDownloadStats(x)
  tail(pkg$Nb_of_downloads, 1)
  }, numeric(1L))
bioc_pkg <- data.frame(package = names(bioc_d), downloads = bioc_d)
downloads <- rbind(bioc_pkg, cran_pkg)
rownames(downloads) <- downloads$package
dwn <- downloads[all_unique_deps, ]
```

## Analysis

Now, we can start looking all the data gathered:

```{r all_together}
repo <- vector("character", length(all_unique_deps))
ap_deps <- ap[all_unique_deps, ]
repo[startsWith(ap_deps[, "Repository"], "https://bioc")] <- "Bioconductor"
repo[!startsWith(ap_deps[, "Repository"], "https://bioc")] <- "CRAN"
deps <- data.frame(package = all_unique_deps,
                   direct_dep_XML = all_unique_deps %in% all_deps$XML,
                   direct_dep_RCurl = all_unique_deps %in% all_deps$RCurl,
                   first_deps_n = lengths(first_deps),
                   deps_all_n = lengths(deps_all),
                   first_rdeps_n = lengths(first_rdeps),
                   releases = releases,
                   strong = strong, 
                   first_release = first_release,
                   last_release = last_update,
                   maintainer = maintainers,
                   downloads = dwn$downloads,
                   repository = repo) |> 
  mutate(type = case_when(direct_dep_XML & direct_dep_RCurl ~ "both",
                          direct_dep_XML ~ "XML",
                          direct_dep_RCurl ~ "RCurl"))
rownames(deps) <- NULL
head(deps)
```

First of all, there is a significant amount of packages at Bioconductor. 

## Circular dependency

Both XML and RCurl are in the list of dependencies. 

We can see that the packages are direct dependencies of one of their direct dependencies!
How can be that? 
If we go the the [RCurl](https://cran.r-project.org/package=RCurl) website we see in Suggests XML, and in the [XML](https://cran.r-project.org/package=XML) website the RCurl is there too.
This circular dependency is allowed because they have each other in Suggests. 

A first step to reduce any possible problem would be to separate them.
This would make it easier understanding which package is worth prioritizing and possible missteps will have less impact.

If we look at [XML source code for RCurl we find](https://github.com/search?q=repo%3Acran%2FXML%20RCurl&type=code) some code in `inst/` folder. 
If these two cases were removed the package could remove its dependency to RCurl. 

Similarly, if we look at [RCurl source code for XML we find](https://github.com/search?q=repo%3Acran%2FRCurl%20XML&type=code) some code in `inst/` folder and in some examples. 
If these three cases were removed the package could remove its dependency to XML.

## Dependencies

Let's see how many packages depend in each of them:

```{r direct_deps}
deps |> 
  group_by(direct_dep_XML, direct_dep_RCurl) |> 
  summarise(Packages = n(), deps = sum(first_deps_n),
            q25 = quantile(deps_all_n, probs = 0.25),
            mean_all = mean(deps_all_n),
            median_all = median(deps_all_n),
            q75 = quantile(deps_all_n, probs = 0.75),
            ) |> 
  arrange(-Packages)
```

There are ~40 more packages depending on XML than to RCurl and just `r sum(deps$direct_dep_XML & deps$direct_dep_RCurl)` to both of them.


```{r}
library("ggplot2")
library("ggrepel")
ggplot(deps) +
  geom_point(aes(first_deps_n, downloads, shape = type)) +
  geom_text_repel(aes(first_deps_n, downloads, label = package)) +
  theme_minimal() +
  scale_y_log10(labels = scales::label_log()) +
  labs(title = "Packages and downloads", 
       x = "Direct dependencies", y = "Downloads", size = "Packages")
```

```{r}
ggplot(deps) +
  geom_point(aes(first_deps_n, first_rdeps_n, shape = type)) +
  geom_text_repel(aes(first_deps_n, first_rdeps_n, label = package)) +
  theme_minimal() +
  scale_y_log10(labels = scales::label_log()) +
  labs(title = "Few dependencies but lots of dependents",
    x = "Direct dependencies", y = "Depend on them", size = "Packages")
```

```{r plot-maintainers}
deps_wo <- filter(deps, !package %in% c("XML", "RCurl"))
deps_wo |> 
  filter(!is.na(maintainer)) |> 
  summarize(n = n(), downlods = sum(downloads), .by = maintainer) |> 
  ggplot() +
  geom_point(aes(n, downlods)) +
  geom_text_repel(aes(n, downlods, label = maintainer)) +
  scale_y_log10(labels = scales::label_log()) +
  scale_x_continuous(breaks = 1:10) +
  theme_minimal() +
  labs(title = "Maintainers that depend on XML and RCurl",
       x = "Packages", y = "Downloads")
```


To avoid over plotting we can explore which variables are more important and how:

```{r pca}
p <- prcomp(deps_wo[, c(4:6, 8, 12)], scale. = TRUE, center = TRUE)
summary(p)
pca <- cbind(p$x, deps_wo)
ggplot(pca) +
  geom_point(aes(PC1, PC2, col = repository, shape = repository)) +
  geom_text_repel(aes(PC1, PC2, label = package), max.overlaps = 15) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  labs(title = "PCA of the numeric variables")
```

We can see in the first PCA some packages that have many downloads and/or depend on many packages.
The second one are packages with many dependencies, as explained by `rotation`:

```{r pca-rotation}
p$rotation[, 1:2]
```



```{r pca2}
p2 <- prcomp(deps_wo[deps_wo$strong, c(4:6, 12)], scale. = TRUE, center = TRUE)
summary(p2)
pca2 <- cbind(p2$x, deps_wo[deps_wo$strong, ])
ggplot(pca2) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  geom_point(aes(PC1, PC2, col = repository, shape = repository)) +
  geom_text_repel(aes(PC1, PC2, label = package), max.overlaps = 15) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  labs(title = "Important pacakges depending on XML and RCurl", 
       subtitle = "PCA of numeric variables of strong dependencies",
       col = "Repository", shape = "Repository")
```

rlist has as dependency XML and only uses 3 functions from it. 

The main packages that depend on XML and RCurl are from Biocondcutor

## Outro

I recently found this as opposite of introduction/intro. 

I wanted to explore a bit how these packages got into this position.

```{r deps-time}
deps |> 
  filter(strong) |> 
  ggplot() +
  geom_vline(xintercept = as.Date("2013-06-15"), linetype = 2) +
  geom_label(aes(first_release, downloads, label = package),
             data = deps[c("XML", "RCurl"), ], show.legend = FALSE) +
  geom_point(aes(first_release, downloads, col = type, shape = type, 
                 size = first_deps_n)) +
  theme_minimal() +
  scale_y_log10(labels = scales::label_log()) +
  annotate("text", x = as.Date("2014-6-15"), y = 5*10^5, 
           label = "CRAN maintained", hjust = 0) +
  labs(x = "Release date", y = "Downloads", 
       title = "More packages added after CRAN maintenance than before",
       subtitle = "Release date and downloads",
       col = "Depends on", shape = "Depends on", size = "Direct dependencies") 
```

Almost the CRAN team have been maintaining these packages longer than the previous maintainer(s?).

Next, we look at the dependencies added after CRAN started maintaining them

```{r period}
summarize(deps,
          before = sum(first_release <= as.Date("2013-06-15"), na.rm = TRUE), 
          later = sum(first_release > as.Date("2013-06-15"), na.rm = TRUE),
          .by = type)
```

Maybe packages authors trusted the CRAN team for their dependencies or there was no other alternative for the functionality. 

A replacment for XML could be [xml2](https://cran.r-project.org/package=xml2), first released in 2015 (which uses the same system dependency libxml2).
A replacment for RCurl could be [curl](https://cran.r-project.org/package=curl), first released at the end of 2014 (which uses the same system dependency libcurl). 
# Recomendations

As a final recommendations I think:

 - Disentangle the XML and RCurl circular dependency.
 - Evaluate if the xml2 and curl packages provides enough functionality to replace XML and RCurl respectively.
 - If their provide enough, contact package maintainers X to replace their functionality with xml2 and curl dependencies or others.
 - Set warnings of deprecation on the XML and RCurl packages.
 - Archive XML and RCurl packages in CRAN. 

### Reproducibility

<details>
```{r reproducibility, echo = FALSE}
## Reproducibility info
options(width = 120)
sessioninfo::session_info()
```
</details>
